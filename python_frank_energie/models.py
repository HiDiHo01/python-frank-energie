"""Data models enable parsing and processing of the Frank Energie API responses in a structured manner."""
# python_frank_energie/models.py

import logging
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import date, datetime, timedelta, timezone, tzinfo
from statistics import mean
from typing import Iterator, Optional, Set, Union

import jwt
import pytz

from jwt.exceptions import InvalidTokenError
from dateutil.parser import parse
from pydantic import BaseModel, EmailStr

from .exceptions import AuthException, RequestException
from .time_periods import TimePeriod

DEFAULT_ROUND = 6

_LOGGER: logging.Logger = logging.getLogger(__name__)

VERSION = "2025.5.23"
FETCH_TOMORROW_HOUR_UTC = 12

@dataclass
class Authentication:
    """Authentication data.

    Generated by the login or renewToken mutation.

    authToken: The token to use for authenticated requests.
    refreshToken: The token to use to renew the authToken.
    """

    authToken: str
    refreshToken: str
    expires_at: datetime | None = None

    @staticmethod
    def from_dict(data: dict[str, str]) -> 'Authentication':
        """Parse the response from the login or renewToken mutation."""
        _LOGGER.debug("Authentication %s", data)

        if errors := data.get("errors"):
            raise AuthException(errors[0]["message"])

        login_payload = data.get("data", {}).get("login")
        renew_payload = data.get("data", {}).get("renewToken")
        if not login_payload and not renew_payload:
            raise AuthException("Unexpected response")

        payload = Authentication._extract_payload(data)
        if not payload:
            raise AuthException("Unexpected response")

        _LOGGER.debug("Authentication payload: %s", payload)
        auth_token = payload.get("authToken")
        refresh_token = payload.get("refreshToken")

        expires_at = None
        if auth_token:
            try:
                decoded = jwt.decode(
                    auth_token,
                    options={"verify_signature": False},
                    algorithms=["HS256"],
                )
                _LOGGER.debug("authToken decoded claims: %s", decoded)
                exp_ts = decoded.get("exp")
                if exp_ts:
                    expires_at = datetime.fromtimestamp(exp_ts, tz=timezone.utc)
                else:
                    _LOGGER.warning("authToken missing 'exp' claim; treating as expired")
                    expires_at = None
                _LOGGER.debug("authToken expires at: %s", expires_at)
            except InvalidTokenError as err:
                _LOGGER.warning("Unable to decode authToken to extract expiration: %s", err)

        return Authentication(
            authToken=auth_token,
            refreshToken=refresh_token,
            expires_at=expires_at,
        )

    @staticmethod
    def _extract_payload(data: dict) -> Optional[dict]:
        """Extract the login or renewToken payload from the data dictionary."""
        return data.get("data", {}).get("login") or data.get("data", {}).get("renewToken")

    def old_authTokenValid(self, tz: timezone = timezone.utc) -> bool:
        """Return that authToken is valid according to expiration time."""
        authTokenDecoded = jwt.decode(
            self.authToken,
            verify=True,
            algorithms=["HS256"],
            options={"verify_signature": False},
        )
        return datetime.fromtimestamp(
            authTokenDecoded["exp"], tz=timezone.utc
        ) > datetime.now(tz=tz)

    def old_auth_token_valid(self, tz: tzinfo = timezone.utc) -> bool:
        """
        Check if the authToken is still valid based on its expiration timestamp.

        Args:
            tz (tzinfo): The timezone to compare the expiration against. Defaults to UTC.

        Returns:
            bool: True if the token is still valid, False otherwise.

        Raises:
            ValueError: If the authToken is missing or malformed.
        """
        if not self.authToken:
            raise ValueError("authToken is missing or not set.")

        try:
            auth_token_decoded = jwt.decode(
                self.authToken,
                options={"verify_signature": False},
                algorithms=["HS256"],
            )
        except InvalidTokenError as err:
            _LOGGER.warning("Failed to decode authToken: %s", err)
            raise ValueError("Malformed authToken.") from err

        expiration = datetime.fromtimestamp(auth_token_decoded.get("exp", 0), tz=timezone.utc)
        return expiration > datetime.now(tz=tz)

    @property
    def is_expired(self) -> bool:
        """Check if the token is expired based on the expires_at field."""
        return not self.expires_at or datetime.now(timezone.utc) >= self.expires_at

@dataclass
class Invoice:
    """Represents invoice information, including the start date, period
    description, and total amount."""

    StartDate: datetime
    PeriodDescription: str
    TotalAmount: float

    @property
    def for_last_year(self) -> bool:
        """Whether this invoice is for the current year."""
        last_year = datetime.now(pytz.timezone('Europe/Amsterdam')).year - 1
        invoice_start_date_utc = self.StartDate.replace(tzinfo=pytz.UTC)
        invoice_start_year = invoice_start_date_utc.astimezone(
            pytz.timezone('Europe/Amsterdam')).year
        return invoice_start_year == last_year

    @property
    def for_this_year(self) -> bool:
        """Whether this invoice is for the current year."""
        current_year = datetime.now(
            pytz.timezone('Europe/Amsterdam')).year
        invoice_start_date_utc = self.StartDate.replace(tzinfo=pytz.UTC)
        invoice_start_year = invoice_start_date_utc.astimezone(
            pytz.timezone('Europe/Amsterdam')).year
        return invoice_start_year == current_year

    @staticmethod
    def from_dict(data: dict[str, object]) -> Optional['Invoice']:
        """Parse the response from the invoice query."""
        if data is None:
            return None

        if isinstance(data, list):
            return [Invoice.from_dict(item) for item in data]

        return Invoice(
            StartDate=parse(data.get("StartDate")).astimezone(
                pytz.timezone('Europe/Amsterdam')),
            PeriodDescription=data.get("PeriodDescription"),
            TotalAmount=float(data.get("TotalAmount")),
        )

@dataclass
class Invoices:
    """Represents invoices including historical, current, and upcoming periods."""

    def __init__(
        self,
        allPeriodsInvoices: Optional[list[Invoice]] = None,
        previousPeriodInvoice: Optional[Invoice] = None,
        currentPeriodInvoice: Optional[Invoice] = None,
        upcomingPeriodInvoice: Optional[Invoice] = None,
        AllInvoicesDictForPreviousYear: dict = None,
        AllInvoicesDictForThisYear: dict = None,
        AllInvoicesDict: dict = None,
        TotalCostsPreviousYear: float = 0.0,
        TotalCostsThisYear: float = 0.0,
    ):
        if allPeriodsInvoices is None:
            allPeriodsInvoices = []
        if AllInvoicesDictForPreviousYear is None:
            AllInvoicesDictForPreviousYear = {}
        if AllInvoicesDictForThisYear is None:
            AllInvoicesDictForThisYear = {}
        if AllInvoicesDict is None:
            AllInvoicesDict = {}
        self.allPeriodsInvoices = allPeriodsInvoices
        self.previousPeriodInvoice = previousPeriodInvoice
        self.currentPeriodInvoice = currentPeriodInvoice
        self.upcomingPeriodInvoice = upcomingPeriodInvoice
        self.AllInvoicesDictForPreviousYear = AllInvoicesDictForPreviousYear
        self.AllInvoicesDictForThisYear = AllInvoicesDictForThisYear
        self.AllInvoicesDict = AllInvoicesDict
        self.TotalCostsPreviousYear = TotalCostsPreviousYear
        self.TotalCostsThisYear = TotalCostsThisYear

    def get_all_invoices_dict_for_previous_year(self) -> dict:
        """Retrieve all invoices for the specified year as a dictionary."""
        previous_year = datetime.now(timezone.utc).year - 1
        invoices_dict = {}

        for invoice in self.get_invoices_for_year(previous_year):
            if invoice.PeriodDescription in invoices_dict:
                invoices_dict[invoice.PeriodDescription]["Total amount"] += invoice.TotalAmount
            else:
                invoices_dict[invoice.PeriodDescription] = {
                    "Start date": invoice.StartDate.astimezone(pytz.timezone('Europe/Amsterdam')),
                    "Period description": invoice.PeriodDescription,
                    "Total amount": invoice.TotalAmount
                }

        return invoices_dict

    def get_all_invoices_dict_for_this_year(self) -> dict:
        """Retrieve all invoices for the specified year as a dictionary."""
        current_year = datetime.now(timezone.utc).year
        invoices_dict = {}

        for invoice in self.get_invoices_for_year(current_year):
            if invoice.PeriodDescription in invoices_dict:
                invoices_dict[invoice.PeriodDescription]["Total amount"] += invoice.TotalAmount
            else:
                invoices_dict[invoice.PeriodDescription] = {
                    "Start date": invoice.StartDate.astimezone(pytz.timezone('Europe/Amsterdam')),
                    "Period description": invoice.PeriodDescription,
                    "Total amount": invoice.TotalAmount
                }

        return invoices_dict

    def get_all_invoices_dict_per_year(self) -> dict:
        """Calculate totals per year and return as a dictionary."""
        all_invoices_dict = defaultdict(lambda: {"Total amount": 0.0})

        for invoice in self.allPeriodsInvoices:
            year = invoice.StartDate.year
            all_invoices_dict[year]["Start date"] = invoice.StartDate.astimezone(
                pytz.timezone('Europe/Amsterdam'))
            all_invoices_dict[year]["Period description"] = f"Total for {year}"
            all_invoices_dict[year]["Total amount"] += invoice.TotalAmount

        return dict(all_invoices_dict)

    def get_all_invoices_dict(self) -> dict:
        """Retrieve all invoices as a dictionary and sum duplicates."""
        invoices_dict = {}

        sorted_invoices = sorted(
            self.allPeriodsInvoices, key=lambda invoice: invoice.StartDate)

        for invoice in sorted_invoices:
            if invoice.PeriodDescription in invoices_dict:
                invoices_dict[invoice.PeriodDescription]["Total amount"] += invoice.TotalAmount
            else:
                invoices_dict[invoice.PeriodDescription] = {
                    "Start date": invoice.StartDate.astimezone(pytz.timezone('Europe/Amsterdam')),
                    "Period description": invoice.PeriodDescription,
                    "Total amount": invoice.TotalAmount
                }

        return invoices_dict

    def get_invoices_for_year(self, year: int) -> list['Invoice']:
        """Filter invoices based on the specified year, considering timezone difference."""
        europe_amsterdam_timezone = pytz.timezone('Europe/Amsterdam')
        start_of_year_utc2 = europe_amsterdam_timezone.localize(
            datetime(year, 1, 1, 0, 0, 0))
        end_of_year_utc2 = start_of_year_utc2.replace(
            month=12, day=31, hour=23, minute=59, second=59)

        filtered_invoices = [
            invoice for invoice in self.allPeriodsInvoices
            if invoice.StartDate >= start_of_year_utc2.astimezone(pytz.UTC) and
            invoice.StartDate <= end_of_year_utc2.astimezone(pytz.UTC)
        ]

        filtered_invoices.sort(key=lambda invoice: invoice.StartDate)
        return filtered_invoices

    def calculate_total_costs(self, year: int) -> float:
        """Calculate the total costs for the specified year using allPeriodsInvoices."""
        return sum(invoice.TotalAmount for invoice in self.get_invoices_for_year(year))

    def calculate_average_costs_per_month(self, year: int = None) -> Optional[float]:
        """Calculate the average costs per month."""
        if year is None:
            invoices = self.allPeriodsInvoices
        else:
            invoices = self.get_invoices_for_year(year)

        invoices_count = 0
        total_costs = 0.0
        unique_months = set()

        for invoice in invoices:
            # Set invoice to PeriodDescription
            invoice_month = invoice.PeriodDescription

            # Check if the month has already been counted
            # Do not count duplicate invoices and invoices with " tot " in the PeriodDescription
            if invoice_month not in unique_months and " tot " not in invoice_month:
                # ensure that we only count each month once.
                invoices_count += 1
                unique_months.add(invoice_month)

            total_costs += invoice.TotalAmount

        if invoices_count == 0:
            return None

        average_costs = total_costs / invoices_count

        return average_costs

    def calculate_expected_costs_this_year(self) -> Optional[float]:
        """Calculate the expected costs for the current year."""
        current_year = datetime.now().year

        # Calculate the average costs per month for the current year
        average_costs_per_month = self.calculate_average_costs_per_month(
            year=current_year)

        if average_costs_per_month is None:
            return None

        # Multiply the average costs per month by 12 to get the expected costs for the year
        expected_costs_this_year = average_costs_per_month * 12

        return expected_costs_this_year

    def get_unique_years(self) -> Set[int]:
        """Get the unique years present in allPeriodsInvoices."""
        unique_years = {
            invoice.StartDate.year for invoice in self.allPeriodsInvoices}
        return unique_years

    def calculate_average_costs_per_year(self) -> Optional[float]:
        """Calculate the average costs for the specified year."""
        invoices = self.allPeriodsInvoices

        if not invoices:
            return None

        total_costs = sum(invoice.TotalAmount for invoice in invoices)
        unique_years_count = len(self.get_unique_years())

        # Avoid division by zero
        if unique_years_count == 0:
            return None

        average_costs = total_costs / unique_years_count

        return average_costs

    def calculate_average_costs_per_month_this_year(self) -> Optional[float]:
        """Calculate the average costs per month for this year."""
        invoices_count = 0
        total_costs = 0.0

        current_year = datetime.now(timezone.utc).year

        for invoice in self.allPeriodsInvoices:
            if invoice.StartDate.year == current_year:
                if " tot " not in invoice.PeriodDescription:
                    invoices_count += 1
                    total_costs += invoice.TotalAmount
                else:
                    total_costs += invoice.TotalAmount

        if invoices_count == 0:
            return None

        current_month = datetime.now(timezone.utc).month
        average_costs = total_costs / invoices_count

        if current_month == 1:
            # Handle January case, as it's the first month of the year
            average_costs *= 12
        else:
            average_costs *= 12 / current_month

        return average_costs

    @staticmethod
    def from_dict(data: dict[str, object]) -> 'Invoices':
        """Parse the response from the invoices query."""
        _LOGGER.debug("Invoices %s", data)

        if errors := data.get("errors"):
            raise RequestException(errors[0]["message"])

        payload = data.get("data", {}).get("invoices")
        if not payload:
            raise RequestException("Unexpected response")

        invoices_instance = Invoices(
            allPeriodsInvoices=Invoice.from_dict(
                payload.get("allInvoices")
            ),
            previousPeriodInvoice=Invoice.from_dict(
                payload.get("previousPeriodInvoice")
            ),
            currentPeriodInvoice=Invoice.from_dict(
                payload.get("currentPeriodInvoice")
            ),
            upcomingPeriodInvoice=Invoice.from_dict(
                payload.get("upcomingPeriodInvoice")
            ),
        )

        current_year = datetime.now(timezone.utc).year
        previous_year = current_year - 1

        invoices_instance.TotalCostsPreviousYear = invoices_instance.calculate_total_costs(
            previous_year)
        invoices_instance.TotalCostsThisYear = invoices_instance.calculate_total_costs(
            current_year)
        invoices_instance.AllInvoicesDictForPreviousYear = invoices_instance.get_all_invoices_dict_for_previous_year()
        invoices_instance.AllInvoicesDictForThisYear = invoices_instance.get_all_invoices_dict_for_this_year()
        invoices_instance.AllInvoicesDict = invoices_instance.get_all_invoices_dict()
        return invoices_instance

@dataclass
class UsageItem:
    """Representeert een individueel gebruiksitem binnen een periode."""

    date: str
    from_time: str
    till_time: str
    usage: float
    costs: float
    unit: str

    @staticmethod
    def from_dict(data: dict[str, object]) -> 'UsageItem':
        """Maakt een UsageItem-object aan vanuit een dictionary."""
        try:
            return UsageItem(
                date=str(data["date"]),
                from_time=str(data["from"]),
                till_time=str(data["till"]),
                usage=float(data["usage"]),
                costs=float(data["costs"]),
                unit=str(data["unit"]),
            )
        except KeyError as e:
            raise ValueError(f"Ontbrekend veld {e.args[0]} in UsageItem data: {data}") from e
        except (ValueError, TypeError) as e:
            raise ValueError(f"Fout bij conversie van UsageItem data: {e}, data: {data}") from e

@dataclass
class EnergyCategory:
    """Representeert een energiecategorie zoals gas, elektriciteit of teruglevering."""

    usage_total: float
    costs_total: float
    unit: str
    items: list[UsageItem]

    @staticmethod
    def from_dict(data: dict[str, object]) -> 'EnergyCategory':
        """Creates an EnergyCategory object from a dictionary."""
        _LOGGER.debug("EnergyCategory.from_dict() called with data: %s", data)
        try:
            if data is None:
                return None

            usage_total = float(data["usageTotal"]) if data.get("usageTotal") is not None else 0.00
            costs_total = float(data["costsTotal"]) if data.get("costsTotal") is not None else 0.00

            return EnergyCategory(
                usage_total=usage_total,
                costs_total=costs_total,
                unit=str(data["unit"]),
                items=[UsageItem.from_dict(item) for item in data.get("items", []) or []],
            )
        except KeyError as e:
            raise ValueError(f"Missing field {e.args[0]} in EnergyCategory data: {data}") from e
        except (ValueError, TypeError) as e:
            raise ValueError(f"Error converting EnergyCategory data: {e}, data: {data}") from e

@dataclass
class PeriodUsageAndCosts:
    """Bevat het verbruik en de kosten van gas, elektriciteit en teruglevering voor een periode."""

    _id: str
    gas: Optional[EnergyCategory]
    electricity: Optional[EnergyCategory]
    feed_in: Optional[EnergyCategory]

    @staticmethod
    def from_dict(data: dict[str, object]) -> 'PeriodUsageAndCosts':
        """Maakt een PeriodUsageAndCosts-object aan vanuit een dictionary."""
        try:
            input_data = data.get("data")
            period_data = input_data.get("periodUsageAndCosts")
            if not period_data:
                return None

            gas_data = period_data.get("gas") if period_data.get("gas") is not None else None
            feed_in_data = period_data.get("feedIn") if period_data.get("feedIn") is not None else None
            electricity_data = period_data.get("electricity") if period_data.get("electricity") is not None else None

            return PeriodUsageAndCosts(
                _id=str(period_data["_id"]),
                gas=EnergyCategory.from_dict(gas_data) if gas_data else None,
                electricity=EnergyCategory.from_dict(electricity_data) if electricity_data else None,
                feed_in=EnergyCategory.from_dict(feed_in_data) if feed_in_data else None,
            )
        except KeyError as e:
            raise ValueError(f"Ontbrekend veld {e.args[0]} in PeriodUsageAndCosts data: {data}") from e
        except (ValueError, TypeError) as e:
            raise ValueError(f"Fout bij conversie van PeriodUsageAndCosts data: {e}, data: {data}") from e

@dataclass
class UserSites:
    """UserSites data."""

    deliverySites: list[object]
    addressFormatted: str
    addressHasMultipleSites: bool
    deliveryEndDate: Optional[str]
    deliveryStartDate: Optional[str]
    firstMeterReadingDate: Optional[str]
    lastMeterReadingDate: Optional[str]
    propositionType: Optional[str]
    reference: str
    segments: list[str]
    status: str

    @staticmethod
    def from_dict(data: dict[str, str]) -> 'UserSites':
        """Parse the response from the UserSites query."""
        _LOGGER.debug("UserSites %s", data)

        if errors := data.get("errors"):
            raise RequestException(errors[0]["message"])

        if 'errors' in data:
            raise RequestException(data['errors'][0]['message'])

        user_sites = data.get("data", {}).get("userSites")
        if not user_sites or not isinstance(user_sites, list):
            raise RequestException("Unexpected response format for userSites")

        first_meter_reading_date: Optional[str] = None
        last_meter_reading_date: Optional[str] = None
        if user_sites and isinstance(user_sites, list):
            first_site = user_sites[0]
            first_meter_reading_date = first_site.get("firstMeterReadingDate")
            last_meter_reading_date = first_site.get("lastMeterReadingDate")

        return UserSites(
            addressFormatted=first_site.get("addressFormatted"),
            addressHasMultipleSites=first_site.get("addressHasMultipleSites"),
            deliveryEndDate=first_site.get("deliveryEndDate"),
            deliveryStartDate=first_site.get("deliveryStartDate"),
            firstMeterReadingDate=first_meter_reading_date,
            lastMeterReadingDate=last_meter_reading_date,
            propositionType=first_site.get("propositionType"),
            reference=first_site.get("reference"),
            segments=first_site.get("segments"),
            status=first_site.get("status"),
            deliverySites=[
                DeliverySite.from_dict(site) for site in user_sites
            ] if 'DeliverySite' in globals() else [],
        )

    @property
    def old_format_delivery_site_as_dict(self):
        sites_as_dict = []
        for site in self.deliverySites:
            address = site.get('address', {})
            sites_as_dict.append(
                f"{address.get('street')} {address.get('houseNumber')} {address.get('houseNumberAddition', '') if address.get('houseNumberAddition') else ''} {address.get('zipCode')} {address.get('city')}")
        return sites_as_dict

    @property
    def old2_format_delivery_site_as_dict(self) -> list[str]:
        """Format delivery site information as a list of formatted addresses."""
        sites_as_dict = []
        for site in self.deliverySites:
            address = getattr(site, 'address', {})
            sites_as_dict.append(
                f"{address.get('street', '')} {address.get('houseNumber', '')} "
                f"{address.get('houseNumberAddition', '') if address.get('houseNumberAddition') else ''} "
                f"{address.get('zipCode', '')} {address.get('city', '')}".strip()
            )
        return sites_as_dict

    @property
    def format_delivery_site_as_dict(self) -> list[str]:
        """Format delivery site information as a list of formatted addresses."""
        sites_as_dict = []
        for site in self.deliverySites:
            address = getattr(site, 'address', None)

            if address:
                sites_as_dict.append(
                    f"{getattr(address, 'street', '')} {getattr(address, 'houseNumber', '')} "
                    f"{getattr(address, 'houseNumberAddition', '') if getattr(address, 'houseNumberAddition', None) else ''} "
                    f"{getattr(address, 'zipCode', '')} {getattr(address, 'city', '')}".strip()
                )
        return sites_as_dict

# ... rest of the file unchanged ...

@dataclass
class Price:
    date_from: datetime
    date_till: datetime
    price_data: list['Price']
    energy_type: Optional[str] = None
    market_price: float = 0.0
    market_price_tax: float = 0.0
    sourcing_markup_price: float = 0.0
    energy_tax_price: float = 0.0
    total: float = 0.0
    per_unit: Optional[str] = None
    unit: Optional[str] = None
    tax_rate: float = 0.0
    tax: float = 0.0
    start_time: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    for_now: bool = False
    for_today: bool = False
    for_tomorrow: bool = False
    for_upcoming: bool = False
    market_price_including_tax: float = 0.0
    market_price_including_tax_and_markup: float = 0.0

    def __post_init__(self):
        if self.energy_type:
            if self.energy_type == "electricity":
                self.energy_tax_price = 0.1228634
            if self.energy_type == "gas":
                self.energy_tax_price = 0.6995736

    def __init__(self, data: dict, energy_type: Optional[str] = None) -> None:
        self.energy_type = energy_type

        date_from_str = data.get('from', '')
        date_till_str = data.get('till', '')
        self.date_from = None
        self.date_till = None

        if date_from_str:
            try:
                date_str = date_from_str.replace('Z', '+00:00')
                dt = datetime.fromisoformat(date_str)
                iso_format_date = dt.isoformat()
                self.date_from = datetime.fromisoformat(iso_format_date)
            except ValueError:
                logging.warning("Invalid ISO date format: '%s'", date_from_str)

        if date_till_str:
            try:
                date_str = date_till_str.replace('Z', '+00:00')
                dt = datetime.fromisoformat(date_str)
                iso_format_date = dt.isoformat()
                self.date_till = datetime.fromisoformat(iso_format_date)
            except ValueError:
                logging.warning("Invalid ISO date format: '%s'", date_till_str)

        self.market_price = data["marketPrice"]
        self.market_price_tax = data["marketPriceTax"]
        self.sourcing_markup_price = data["sourcingMarkupPrice"]
        self.energy_tax_price = data["energyTaxPrice"]
        self.market_price_including_tax = self.market_price + self.market_price_tax
        self.market_price_including_tax_and_markup = (
            self.market_price + self.market_price_tax + self.sourcing_markup_price
        )
        self.per_unit = data['perUnit']

    def __str__(self) -> str:
        return "%s -> %s: %.4f %s" % (
            self.date_from.isoformat() if self.date_from else "N/A",
            self.date_till.isoformat() if self.date_till else "N/A",
            self.total,
            self.per_unit or ""
        )

    @property
    def ET(self, data) -> str:
        if "energy_type" in data:
            self.energy_type = data["energy_type"]
            if self.energy_type == "electricity":
                self.energy_tax_price = 0.1228634
            if self.energy_type == "gas":
                self.energy_tax_price = 0.6995736
            return data["energy_type"]
        else:
            return None

    @property
    def for_now(self) -> bool:
        return self.date_from <= datetime.now(timezone.utc) < self.date_till

    @property
    def for_future(self) -> bool:
        return self.date_from.hour > datetime.now(timezone.utc).hour

    @property
    def for_today(self) -> bool:
        now = datetime.now(timezone.utc).astimezone()
        day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        day_end = day_start + timedelta(days=1)
        return self.date_from >= day_start and self.date_till <= day_end

    @property
    def for_tomorrow(self) -> bool:
        now = datetime.now(timezone.utc).astimezone()
        tomorrow = now + timedelta(days=1)
        tomorrow_start = tomorrow.replace(
            hour=0, minute=0, second=0, microsecond=0)
        tomorrow_end = tomorrow_start + timedelta(days=1)
        return tomorrow_start <= self.date_from < tomorrow_end

    @property
    def for_upcoming(self) -> bool:
        now = datetime.now(timezone.utc).astimezone()
        return self.date_from > now

    @property
    def for_previous_hour(self) -> bool:
        now = datetime.now(timezone.utc).astimezone()
        previous_hour_start = now.replace(
            microsecond=0, second=0, minute=0) - timedelta(hours=1)
        return self.date_from == previous_hour_start

    @property
    def for_next_hour(self) -> bool:
        now = datetime.now(timezone.utc).astimezone()
        next_hour_start = now.replace(
            microsecond=0, second=0, minute=0) + timedelta(hours=1)
        next_hour_end = next_hour_start + timedelta(hours=1)
        return next_hour_start <= self.date_from < next_hour_end

    @property
    def previous_hour(self):
        return next((hour for hour in self.price_data if hour.for_previous_hour), None)

    @property
    def next_hour(self):
        return next((hour for hour in self.price_data if hour.for_next_hour), None)

    @property
    def market_price_with_tax(self) -> float:
        """The market price including tax."""
        return self.market_price + self.market_price_tax

    @property
    def market_price_with_tax_and_markup(self) -> float:
        """The market price including tax."""
        return self.market_price + self.market_price_tax + self.sourcing_markup_price

    @property
    def total(self) -> float:
        """The total price for this hour."""
        if not hasattr(self, '_total'):
            self._total = (
                self.market_price +
                self.market_price_tax +
                self.sourcing_markup_price +
                self.energy_tax_price
            )
        return self._total

    def calculate_stats1(self, prices: list['Price']) -> dict[str, float]:
        if not prices:
            return {}

        price_values = [price.market_price for price in prices]
        total_prices = [price.total for price in prices]
        return {
            "min": min(price_values),
            "max": max(price_values),
            "avg": mean(total_prices),
        }

    @staticmethod
    def calculate_stats2(prices: list[float]) -> dict[str, float]:
        if not prices:
            return {}

        min_price = min(prices)
        max_price = max(prices)
        avg_price = mean(prices)
        total_price = sum(prices)
        n = len(prices)
        std_dev = (sum((x - avg_price) ** 2 for x in prices) / n) ** 0.5

        stats = {
            'min_price': min_price,
            'max_price': max_price,
            'avg_price': avg_price,
            'total_price': total_price,
            'std_dev': std_dev
        }

        return stats

    @staticmethod
    def calculate_stats3(data: dict) -> dict[str, dict[str, float]]:
        if not data:
            return {}
        electricity_prices = [entry['marketPrice']
                              for entry in data['marketPricesElectricity']]
        gas_prices = [entry['marketPrice']
                      for entry in data['marketPricesGas']]

        electricity_mean = mean(electricity_prices)
        gas_mean = mean(gas_prices)

        electricity_min = min(electricity_prices)
        gas_min = min(gas_prices)

        electricity_max = max(electricity_prices)
        gas_max = max(gas_prices)

        electricity_std_dev = (sum(
            (x - electricity_mean) ** 2 for x in electricity_prices) / len(electricity_prices)) ** 0.5
        gas_std_dev = (
            sum((x - gas_mean) ** 2 for x in gas_prices) / len(gas_prices)) ** 0.5

        return {
            'electricity': {
                'mean': electricity_mean,
                'min': electricity_min,
                'max': electricity_max,
                'std_dev': electricity_std_dev
            },
            'gas': {
                'mean': gas_mean,
                'min': gas_min,
                'max': gas_max,
                'std_dev': gas_std_dev
            }
        }

@dataclass
class PriceData:
    """Price data for a period of time."""
    price_data: list[Price] = []
    energy_type: Optional[str] = None
    current_hour: Price = None
    previous_hour: Price = None
    next_hour: Price = None
    upcoming_min: Price = None
    upcoming_max: Price = None
    upcoming_avg: PriceDataAvg = None
    upcoming_prices: list[Price] = None
    elec_previoushour: float = None
    elec_nexthour: float = None
    gas_unit: str = None
    elec_unit: str = None

    def __init__(self, prices: Optional[list['Price']] = None, energy_type: Optional[str] = None):
        self.price_data = [Price({**price, "energy_type": energy_type})
                           for price in prices] if prices else []
        self.energy_type = energy_type

    def __add__(self, other: 'PriceData') -> 'PriceData':
        pd = PriceData()
        pd.price_data = self.price_data + other.price_data
        return pd

    def __str__(self):
        return str([str(price) for price in self.price_data])

    def filter_prices(self, start_date: datetime, end_date: datetime) -> list[Price]:
        """Filter prices based on start and end dates."""
        return [price for price in self.price_data if start_date <= price.date_from <= end_date]

    @property
    def all(self) -> list[Price]:
        """All prices."""
        return self.price_data

    @property
    def today(self) -> list[Price]:
        """Prices for today."""
        return [hour for hour in self.price_data if hour.for_today]

    @property
    def tomorrow(self) -> list[Price]:
        """Prices for tomorrow."""
        return [hour for hour in self.price_data if hour.for_tomorrow]

    @property
    def previous_hour(self) -> Optional['Price']:
        """ Price that was the previous hour applicable. """
        return next((hour for hour in self.price_data if hour.for_previous_hour), None)

    @property
    def current_hour(self) -> Optional['Price']:
        """ Price that's currently applicable. """
        matching_hours = [hour for hour in self.price_data if hour.for_now]
        if matching_hours:
            return matching_hours[0]
        else:
            return None

    @property
    def next_hour(self) -> Optional['Price']:
        """ Price that's next hour applicable. """
        return next((hour for hour in self.price_data if hour.for_next_hour), None)

    @property
    def today_min(self) -> Optional[Price]:
        """Price with the lowest total for today."""
        if self.today != []:
            return min([hour for hour in self.today], key=lambda hour: hour.total)

    @property
    def today_max(self) -> Optional[Price]:
        """Price with the highest total for today."""
        if self.today != []:
            return max([hour for hour in self.today], key=lambda hour: hour.total)

    @property
    def today_avg(self) -> float:
        """Average price for today."""
        if self.today != []:
            return mean(hour.total for hour in self.today)

    @property
    def tomorrow_min(self) -> Optional[Price]:
        """Price with the lowest total for today."""
        if self.tomorrow != []:
            return min([hour for hour in self.tomorrow], key=lambda hour: hour.total)

    @property
    def tomorrow_max(self) -> Optional[Price]:
        """Price with the highest total for today."""
        if self.tomorrow != []:
            return max([hour for hour in self.tomorrow], key=lambda hour: hour.total)

    # ... rest of the methods unchanged ...
    
    @staticmethod
    def from_be_dict(cls, data: dict[str, object]) -> 'MarketPrices':
        """
        Create MarketPrices instance from BE market prices dict.

        Args:
            data: Dictionary with market prices data in BE format.

        Returns:
            MarketPrices instance populated from the provided dict.
        """
        _LOGGER.debug("BE Market Prices %s", data)

        if not data:
            return cls(PriceData(), PriceData())

        try:
            payload = data.get("data").get("marketPrices", {})
        except KeyError as err:
            raise ValueError("Invalid response format: %s" % err) from err

        electricity_data = payload.get("electricityPrices", {})
        gas_data = payload.get("gasPrices", {})

        electricity_price_data = PriceData(electricity_data, energy_type="electricity")
        gas_price_data = PriceData(gas_data, energy_type="gas")

        return cls(
            electricity=electricity_price_data,
            gas=gas_price_data,
            energy_country="BE"
        )

@dataclass
class Session:
    """A trading session for a battery."""

    date: datetime
    trading_result: float
    cumulative_trading_result: float

    @staticmethod
    def from_dict(payload: dict[str, object]) -> 'SmartBatterySessions.Session':
        """Parse the sessions payload from the SmartBatterySessions query result."""
        _LOGGER.debug("üîÅ Parsing SmartBatterySessions.Session response: %s", payload)

        try:
            return SmartBatterySessions.Session(
                date=datetime.fromisoformat(payload["date"]).astimezone(timezone.utc),
                trading_result=float(payload["tradingResult"]),
                cumulative_trading_result=float(payload["cumulativeTradingResult"]),
            )
        except KeyError as exc:
            raise RequestException("Missing expected field in session: %s" % exc) from exc
        except ValueError as exc:
            raise RequestException("Invalid data format in session payload: %s" % exc) from exc

# ... rest of file unchanged ...