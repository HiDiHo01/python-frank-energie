"""Data models enable parsing and processing of the Frank Energie API responses in a structured manner."""
# python_frank_energie/models.py

import logging
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import date, datetime, timedelta, timezone, tzinfo
from statistics import mean
from typing import Iterator, Optional, Set, Union

import jwt
import pytz

from jwt.exceptions import InvalidTokenError
from dateutil.parser import parse
from pydantic import BaseModel, EmailStr

from .exceptions import AuthException, RequestException
from .time_periods import TimePeriod

DEFAULT_ROUND = 6

_LOGGER: logging.Logger = logging.getLogger(__name__)

VERSION = "2025.5.23"
FETCH_TOMORROW_HOUR_UTC = 12

@dataclass
class Authentication:
    """Authentication data.

    Generated by the login or renewToken mutation.
    authToken: The token to use for authenticated requests.
    refreshToken: The token to use to renew the authToken.
    """
    authToken: str
    refreshToken: str
    expires_at: datetime | None = None

    @staticmethod
    def from_dict(data: dict[str, str]) -> 'Authentication':
        """Parse the response from the login or renewToken mutation."""
        _LOGGER.debug("Authentication %s", data)

        if errors := data.get("errors"):
            raise AuthException(errors[0]["message"])

        login_payload = data.get("data", {}).get("login")
        renew_payload = data.get("data", {}).get("renewToken")
        if not login_payload and not renew_payload:
            raise AuthException("Unexpected response")

        payload = Authentication._extract_payload(data)
        if not payload:
            raise AuthException("Unexpected response")

        _LOGGER.debug("Authentication payload: %s", payload)
        auth_token = payload.get("authToken")
        refresh_token = payload.get("refreshToken")

        expires_at = None
        if auth_token:
            try:
                decoded = jwt.decode(
                    auth_token,
                    options={"verify_signature": False},
                    algorithms=["HS256"],
                )
                _LOGGER.debug("authToken decoded claims: %s", decoded)
                exp_ts = decoded.get("exp")
                if exp_ts:
                    expires_at = datetime.fromtimestamp(exp_ts, tz=timezone.utc)
                else:
                    _LOGGER.warning("authToken missing 'exp' claim; treating as expired")
                    expires_at = None
                _LOGGER.debug("authToken expires at: %s", expires_at)
            except InvalidTokenError as err:
                _LOGGER.warning("Unable to decode authToken to extract expiration: %s", err)

        return Authentication(
            authToken=auth_token,
            refreshToken=refresh_token,
            expires_at=expires_at,
        )

    @staticmethod
    def _extract_payload(data: dict) -> Optional[dict]:
        """Extract the login or renewToken payload from the data dictionary."""
        return data.get("data", {}).get("login") or data.get("data", {}).get("renewToken")

    def old_authTokenValid(self, tz: timezone = timezone.utc) -> bool:
        """Return that authToken is valid according to expiration time."""
        authTokenDecoded = jwt.decode(
            self.authToken,
            verify=True,
            algorithms=["HS256"],
            options={"verify_signature": False},
        )
        return datetime.fromtimestamp(
            authTokenDecoded["exp"], tz=timezone.utc
        ) > datetime.now(tz=tz)

    def old_auth_token_valid(self, tz: tzinfo = timezone.utc) -> bool:
        """
        Check if the authToken is still valid based on its expiration timestamp.

        Args:
            tz (tzinfo): The timezone to compare the expiration against. Defaults to UTC.

        Returns:
            bool: True if the token is still valid, False otherwise.

        Raises:
            ValueError: If the authToken is missing or malformed.
        """
        if not self.authToken:
            raise ValueError("authToken is missing or not set.")

        try:
            auth_token_decoded = jwt.decode(
                self.authToken,
                options={"verify_signature": False},
                algorithms=["HS256"],
            )
        except InvalidTokenError as err:
            _LOGGER.warning("Failed to decode authToken: %s", err)
            raise ValueError("Malformed authToken.") from err

        expiration = datetime.fromtimestamp(auth_token_decoded.get("exp", 0), tz=timezone.utc)
        return expiration > datetime.now(tz=tz)

    @property
    def is_expired(self) -> bool:
        """Check if the token is expired based on the expires_at field."""
        return not self.expires_at or datetime.now(timezone.utc) >= self.expires_at

@dataclass
class Invoice:
    """Represents invoice information, including the start date, period
    description, and total amount."""
    StartDate: datetime
    PeriodDescription: str
    TotalAmount: float

    @property
    def for_last_year(self) -> bool:
        """Whether this invoice is for the current year."""
        last_year = datetime.now(pytz.timezone('Europe/Amsterdam')).year-1
        invoice_start_date_utc = self.StartDate.replace(tzinfo=pytz.UTC)
        invoice_start_year = invoice_start_date_utc.astimezone(
            pytz.timezone('Europe/Amsterdam')).year
        return invoice_start_year == last_year

    @property
    def for_this_year(self) -> bool:
        """Whether this invoice is for the current year."""
        current_year = datetime.now(
            pytz.timezone('Europe/Amsterdam')).year
        invoice_start_date_utc = self.StartDate.replace(tzinfo=pytz.UTC)
        invoice_start_year = invoice_start_date_utc.astimezone(
            pytz.timezone('Europe/Amsterdam')).year
        return invoice_start_year == current_year

    @staticmethod
    def from_dict(data: dict[str, object]) -> Optional['Invoice']:
        """Parse the response from the invoice query."""
        if data is None:
            return None

        if isinstance(data, list):
            return [Invoice.from_dict(item) for item in data]

        return Invoice(
            StartDate=parse(data.get("StartDate")).astimezone(
                pytz.timezone('Europe/Amsterdam')),
            PeriodDescription=data.get("PeriodDescription"),
            TotalAmount=float(data.get("TotalAmount")),
        )

@dataclass
class Invoices:
    """Represents invoices including historical, current, and upcoming periods."""

    def __init__(
        self,
        allPeriodsInvoices: Optional[list[Invoice]] = None,
        previousPeriodInvoice: Optional[Invoice] = None,
        currentPeriodInvoice: Optional[Invoice] = None,
        upcomingPeriodInvoice: Optional[Invoice] = None,
        AllInvoicesDictForPreviousYear: dict = None,
        AllInvoicesDictForThisYear: dict = None,
        AllInvoicesDict: dict = None,
        TotalCostsPreviousYear: float = 0.0,
        TotalCostsThisYear: float = 0.0,
    ):
        if allPeriodsInvoices is None:
            allPeriodsInvoices = []
        if AllInvoicesDictForPreviousYear is None:
            AllInvoicesDictForPreviousYear = {}
        if AllInvoicesDictForThisYear is None:
            AllInvoicesDictForThisYear = {}
        if AllInvoicesDict is None:
            AllInvoicesDict = {}

        self.allPeriodsInvoices = allPeriodsInvoices
        self.previousPeriodInvoice = previousPeriodInvoice
        self.currentPeriodInvoice = currentPeriodInvoice
        self.upcomingPeriodInvoice = upcomingPeriodInvoice
        self.AllInvoicesDictForPreviousYear = AllInvoicesDictForPreviousYear
        self.AllInvoicesDictForThisYear = AllInvoicesDictForThisYear
        self.AllInvoicesDict = AllInvoicesDict
        self.TotalCostsPreviousYear = TotalCostsPreviousYear
        self.TotalCostsThisYear = TotalCostsThisYear

    def get_all_invoices_dict_for_previous_year(self) -> dict:
        """Retrieve all invoices for the specified year as a dictionary."""
        previous_year = datetime.now(timezone.utc).year-1
        invoices_dict = {}

        for invoice in self.get_invoices_for_year(previous_year):
            if invoice.PeriodDescription in invoices_dict:
                invoices_dict[invoice.PeriodDescription]["Total amount"] += invoice.TotalAmount
            else:
                invoices_dict[invoice.PeriodDescription] = {
                    "Start date": invoice.StartDate.astimezone(pytz.timezone('Europe/Amsterdam')),
                    "Period description": invoice.PeriodDescription,
                    "Total amount": invoice.TotalAmount
                }

        return invoices_dict

    def get_all_invoices_dict_for_this_year(self) -> dict:
        """Retrieve all invoices for the specified year as a dictionary."""
        current_year = datetime.now(timezone.utc).year
        invoices_dict = {}

        for invoice in self.get_invoices_for_year(current_year):
            if invoice.PeriodDescription in invoices_dict:
                invoices_dict[invoice.PeriodDescription]["Total amount"] += invoice.TotalAmount
            else:
                invoices_dict[invoice.PeriodDescription] = {
                    "Start date": invoice.StartDate.astimezone(pytz.timezone('Europe/Amsterdam')),
                    "Period description": invoice.PeriodDescription,
                    "Total amount": invoice.TotalAmount
                }

        return invoices_dict

    def get_all_invoices_dict_per_year(self) -> dict:
        """Calculate totals per year and return as a dictionary."""
        all_invoices_dict = defaultdict(lambda: {"Total amount": 0.0})

        for invoice in self.allPeriodsInvoices:
            year = invoice.StartDate.year
            all_invoices_dict[year]["Start date"] = invoice.StartDate.astimezone(
                pytz.timezone('Europe/Amsterdam'))
            all_invoices_dict[year]["Period description"] = f"Total for {year}"
            all_invoices_dict[year]["Total amount"] += invoice.TotalAmount

        return dict(all_invoices_dict)

    def get_all_invoices_dict(self) -> dict:
        """Retrieve all invoices as a dictionary and sum duplicates."""
        invoices_dict = {}

        sorted_invoices = sorted(
            self.allPeriodsInvoices, key=lambda invoice: invoice.StartDate)

        for invoice in sorted_invoices:
            if invoice.PeriodDescription in invoices_dict:
                invoices_dict[invoice.PeriodDescription]["Total amount"] += invoice.TotalAmount
            else:
                invoices_dict[invoice.PeriodDescription] = {
                    "Start date": invoice.StartDate.astimezone(pytz.timezone('Europe/Amsterdam')),
                    "Period description": invoice.PeriodDescription,
                    "Total amount": invoice.TotalAmount
                }

        return invoices_dict

    def get_invoices_for_year(self, year: int) -> list['Invoice']:
        """Filter invoices based on the specified year, considering timezone difference."""
        europe_amsterdam_timezone = pytz.timezone('Europe/Amsterdam')
        start_of_year_utc2 = europe_amsterdam_timezone.localize(
            datetime(year, 1, 1, 0, 0, 0))
        end_of_year_utc2 = start_of_year_utc2.replace(
            month=12, day=31, hour=23, minute=59, second=59)

        filtered_invoices = [
            invoice for invoice in self.allPeriodsInvoices
            if invoice.StartDate >= start_of_year_utc2.astimezone(pytz.UTC) and
            invoice.StartDate <= end_of_year_utc2.astimezone(pytz.UTC)
        ]

        filtered_invoices.sort(key=lambda invoice: invoice.StartDate)
        return filtered_invoices

    def calculate_total_costs(self, year: int) -> float:
        """Calculate the total costs for the specified year using allPeriodsInvoices."""
        return sum(invoice.TotalAmount for invoice in self.get_invoices_for_year(year))

    def calculate_average_costs_per_month(self, year: int = None) -> Optional[float]:
        """Calculate the average costs per month."""
        if year is None:
            invoices = self.allPeriodsInvoices
        else:
            invoices = self.get_invoices_for_year(year)

        invoices_count = 0
        total_costs = 0.0
        unique_months = set()

        for invoice in invoices:
            invoice_month = invoice.PeriodDescription
            if invoice_month not in unique_months and " tot " not in invoice_month:
                invoices_count += 1
                unique_months.add(invoice_month)
            total_costs += invoice.TotalAmount

        if invoices_count == 0:
            return None

        average_costs = total_costs / invoices_count
        return average_costs

    def calculate_expected_costs_this_year(self) -> Optional[float]:
        """Calculate the expected costs for the current year."""
        current_year = datetime.now().year
        average_costs_per_month = self.calculate_average_costs_per_month(
            year=current_year)

        if average_costs_per_month is None:
            return None

        expected_costs_this_year = average_costs_per_month * 12
        return expected_costs_this_year

    def get_unique_years(self) -> Set[int]:
        """Get the unique years present in allPeriodsInvoices."""
        unique_years = {
            invoice.StartDate.year for invoice in self.allPeriodsInvoices}
        return unique_years

    def calculate_average_costs_per_year(self) -> Optional[float]:
        """Calculate the average costs for the specified year."""
        invoices = self.allPeriodsInvoices
        if not invoices:
            return None

        total_costs = sum(invoice.TotalAmount for invoice in invoices)
        unique_years_count = len(self.get_unique_years())

        if unique_years_count == 0:
            return None
        average_costs = total_costs / unique_years_count
        return average_costs

    def calculate_average_costs_per_month_this_year(self) -> Optional[float]:
        """Calculate the average costs per month for this year."""
        invoices_count = 0
        total_costs = 0.0

        current_year = datetime.now(timezone.utc).year

        for invoice in self.allPeriodsInvoices:
            if invoice.StartDate.year == current_year:
                if " tot " not in invoice.PeriodDescription:
                    invoices_count += 1
                    total_costs += invoice.TotalAmount
                else:
                    total_costs += invoice.TotalAmount

        if invoices_count == 0:
            return None

        current_month = datetime.now(timezone.utc).month
        average_costs = total_costs / invoices_count

        if current_month == 1:
            average_costs *= 12
        else:
            average_costs *= 12 / current_month

        return average_costs

    @staticmethod
    def from_dict(data: dict[str, object]) -> 'Invoices':
        """Parse the response from the invoices query."""
        _LOGGER.debug("Invoices %s", data)

        if errors := data.get("errors"):
            raise RequestException(errors[0]["message"])

        payload = data.get("data", {}).get("invoices")
        if not payload:
            raise RequestException("Unexpected response")

        invoices_instance = Invoices(
            allPeriodsInvoices=Invoice.from_dict(
                payload.get("allInvoices")
            ),
            previousPeriodInvoice=Invoice.from_dict(
                payload.get("previousPeriodInvoice")
            ),
            currentPeriodInvoice=Invoice.from_dict(
                payload.get("currentPeriodInvoice")
            ),
            upcomingPeriodInvoice=Invoice.from_dict(
                payload. get("upcomingPeriodInvoice")
            ),
        )

        current_year = datetime.now(timezone.utc).year
        previous_year = current_year - 1

        invoices_instance.TotalCostsPreviousYear = invoices_instance.calculate_total_costs(
            previous_year)
        invoices_instance.TotalCostsThisYear = invoices_instance.calculate_total_costs(
            current_year)
        invoices_instance.AllInvoicesDictForPreviousYear = invoices_instance.get_all_invoices_dict_for_previous_year()
        invoices_instance.AllInvoicesDictForThisYear = invoices_instance.get_all_invoices_dict_for_this_year()
        invoices_instance.AllInvoicesDict = invoices_instance.get_all_invoices_dict()
        return invoices_instance

@dataclass
class UsageItem:
    """Representeert een individueel gebruiksitem binnen een periode."""
    date: str
    from_time: str
    till_time: str
    usage: float
    costs: float
    unit: str

    @staticmethod
    def from_dict(data: dict[str, object]) -> 'UsageItem':
        """Maakt een UsageItem-object aan vanuit een dictionary."""
        try:
            return UsageItem(
                date=str(data["date"]),
                from_time=str(data["from"]),
                till_time=str(data["till"]),
                usage=float(data["usage"]),
                costs=float(data["costs"]),
                unit=str(data["unit"]),
            )
        except KeyError as e:
            raise ValueError(f"Ontbrekend veld {e.args[0]} in UsageItem data: {data}") from e
        except (ValueError, TypeError) as e:
            raise ValueError(f"Fout bij conversie van UsageItem data: {e}, data: {data}") from e

@dataclass
class EnergyCategory:
    """Representeert een energiecategorie zoals gas, elektriciteit of teruglevering."""
    usage_total: float
    costs_total: float
    unit: str
    items: list[UsageItem]

    @staticmethod
    def from_dict(data: dict[str, object]) -> 'EnergyCategory':
        """Creates an EnergyCategory object from a dictionary."""
        _LOGGER.debug("EnergyCategory.from_dict() called with data: %s", data)
        try:
            if data is None:
                return None

            usage_total = float(data["usageTotal"]) if data.get("usageTotal") is not None else 0.00
            costs_total = float(data["costsTotal"]) if data.get("costsTotal") is not None else 0.00

            return EnergyCategory(
                usage_total=usage_total,
                costs_total=costs_total,
                unit=str(data["unit"]),
                items=[UsageItem.from_dict(item) for item in data.get("items", []) or []],
            )
        except KeyError as e:
            raise ValueError(f"Missing field {e.args[0]} in EnergyCategory data: {data}") from e
        except (ValueError, TypeError) as e:
            raise ValueError(f"Error converting EnergyCategory data: {e}, data: {data}") from e

@dataclass
class PeriodUsageAndCosts:
    """Bevat het verbruik en de kosten van gas, elektriciteit en teruglevering voor een periode."""
    _id: str
    gas: Optional[EnergyCategory]
    electricity: Optional[EnergyCategory]
    feed_in: Optional[EnergyCategory]

    @staticmethod
    def from_dict(data: dict[str, object]) -> 'PeriodUsageAndCosts':
        """Maakt een PeriodUsageAndCosts-object aan vanuit een dictionary."""
        try:
            input_data = data.get("data")
            period_data = input_data.get("periodUsageAndCosts")
            if not period_data:
                return None

            gas_data = period_data.get("gas") or None
            feed_in_data = period_data.get("feedIn") or None
            electricity_data = period_data.get("electricity") or None

            return PeriodUsageAndCosts(
                _id=str(period_data["_id"]),
                gas=EnergyCategory.from_dict(gas_data) if gas_data else None,
                electricity=EnergyCategory.from_dict(electricity_data) if electricity_data else None,
                feed_in=EnergyCategory.from_dict(feed_in_data) if feed_in_data else None,
            )
        except KeyError as e:
            raise ValueError(f"Ontbrekend veld {e.args[0]} in PeriodUsageAndCosts data: {data}") from e
        except (ValueError, TypeError) as e:
            raise ValueError(f"Fout bij conversie van PeriodUsageAndCosts data: {e}, data: {data}") from e

@dataclass
class UserSites:
    """UserSites data."""
    deliverySites: list[object]
    addressFormatted: str
    addressHasMultipleSites: bool
    deliveryEndDate: Optional[str]
    deliveryStartDate: Optional[str]
    firstMeterReadingDate: Optional[str]
    lastMeterReadingDate: Optional[str]
    propositionType: Optional[str]
    reference: str
    segments: list[str]
    status: str

    @staticmethod
    def from_dict(data: dict[str, str]) -> 'UserSites':
        """Parse the response from the UserSites query."""
        _LOGGER.debug("UserSites %s", data)

        if errors := data.get("errors"):
            raise RequestException(errors[0]["message"])

        user_sites = data.get("data", {}).get("userSites")
        if not user_sites or not isinstance(user_sites, list):
            raise RequestException("Unexpected response format for userSites")

        first_site = user_sites[0]
        first_meter_reading_date = first_site.get("firstMeterReadingDate")
        last_meter_reading_date = first_site.get("lastMeterReadingDate")

        return UserSites(
            addressFormatted=first_site.get("addressFormatted"),
            addressHasMultipleSites=first_site.get("addressHasMultipleSites"),
            deliveryEndDate=first_site.get("deliveryEndDate"),
            deliveryStartDate=first_site.get("deliveryStartDate"),
            firstMeterReadingDate=first_meter_reading_date,
            lastMeterReadingDate=last_meter_reading_date,
            propositionType=first_site.get("propositionType"),
            reference=first_site.get("reference"),
            segments=first_site.get("segments"),
            status=first_site.get("status"),
            deliverySites=[
                DeliverySite.from_dict(site) for site in user_sites
            ] if 'DeliverySite' in globals() else [],
        )

    @property
    def old_format_delivery_site_as_dict(self):
        sites_as_dict = []
        for site in self.deliverySites:
            address = site.get('address', {})
            sites_as_dict.append(
                f"{address.get('street')} {address.get('houseNumber')} {address.get('houseNumberAddition', '') if address.get('houseNumberAddition') else ''} {address.get('zipCode')} {address.get('city')}")
        return sites_as_dict

    @property
    def old2_format_delivery_site_as_dict(self) -> list[str]:
        """Format delivery site information as a list of formatted addresses."""
        sites_as_dict = []
        for site in self.deliverySites:
            address = getattr(site, 'address', {})
            sites_as_dict.append(
                f"{address.get('street', '')} {address.get('houseNumber', '')} "
                f"{address.get('houseNumberAddition', '') if address.get('houseNumberAddition') else ''} "
                f"{address.get('zipCode', '')} {address.get('city', '')}".strip()
            )
        return sites_as_dict

    @property
    def format_delivery_site_as_dict(self) -> list[str]:
        """Format delivery site information as a list of formatted addresses."""
        sites_as_dict = []
        for site in self.deliverySites:
            address = getattr(site, 'address', None)

            if address:
                sites_as_dict.append(
                    f"{getattr(address, 'street', '')} {getattr(address, 'houseNumber', '')} "
                    f"{getattr(address, 'houseNumberAddition', '') if getattr(address, 'houseNumberAddition', None) else ''} "
                    f"{getattr(address, 'zipCode', '')} {getattr(address, 'city', '')}".strip()
                )
        return sites_as_dict

# ... rest of the file remains unchanged ...


# MarketPrices.from_dict: flatten nested if
@dataclass
class MarketPrices:
    """ Market prices for electricity and gas."""

    electricity: Optional['PriceData'] = None
    gas: Optional['PriceData'] = None
    energy_type: Optional[str] = None
    energy_country: str = "NL"
    today: list = field(default_factory=list)
    tomorrow: list = field(default_factory=list)

    @staticmethod
    def from_dict(data: dict[str, object]) -> 'MarketPrices':
        """Parse the response from the marketPrices query."""
        _LOGGER.debug("Prices %s", data)

        if (errors := data.get("errors")) and errors[0]["message"].startswith("No marketprices found for segment"):
            return MarketPrices(PriceData(), PriceData())
        # original behavior preserves commented-out raise

        payload = data.get("data")
        if payload is None:
            return None

        market_prices_electricity = payload.get("marketPricesElectricity", {})
        market_prices_gas = payload.get("marketPricesGas", {})

        return MarketPrices(
            electricity=PriceData(market_prices_electricity,
                                  energy_type="electricity"),
            gas=PriceData(market_prices_gas, energy_type="gas"),
        )

# Fix f-strings without placeholders

# In from_be_dict:
    @staticmethod
    def from_be_dict(cls, data: dict[str, object]) -> 'MarketPrices':
        _LOGGER.debug("BE Market Prices %s", data)
        if not data:
            return cls(PriceData(), PriceData())
        try:
            payload = data.get("data").get("marketPrices", {})
        except KeyError as err:
            raise ValueError("Invalid response format: %s" % err) from err

# In SmartBatterySessions.Session.from_dict:
    @staticmethod
    def from_dict(payload: dict[str, object]) -> 'SmartBatterySessions.Session':
        _LOGGER.debug("🔁 Parsing SmartBatterySessions.Session response: %s", payload)
        try:
            return SmartBatterySessions.Session(
                date=datetime.fromisoformat(payload["date"]).astimezone(timezone.utc),
                trading_result=float(payload["tradingResult"]),
                cumulative_trading_result=float(payload["cumulativeTradingResult"]),
            )
        except KeyError:
            raise RequestException("Missing expected field in session: %s" % payload) from None
        except ValueError as err:
            raise RequestException("Invalid data format in session payload: %s" % err) from err

# In SmartBatteryDetails.from_dict: remove unused exc and last_update
@dataclass
class SmartBatteryDetails:
    # ...
    @staticmethod
    def from_dict(data: dict[str, object]) -> "SmartBatteryDetails":
        sb_data = data.get("smartBattery", {})
        if not sb_data:
            raise ValueError("No smart battery data found")
        _LOGGER.debug("SmartBatteryDetails %s", sb_data)
        settings_data = sb_data.get("settings", {})
        _LOGGER.debug("SmartBatterySettings %s", settings_data)
        if not settings_data:
            _LOGGER.warning("No settings data found in smart battery data")
            settings_data = {}

        smart_battery_settings = SmartBatterySettings(
            battery_mode=settings_data.get("batteryMode", ""),
            imbalance_trading_strategy=settings_data.get("imbalanceTradingStrategy", ""),
            self_consumption_trading_allowed=settings_data.get("selfConsumptionTradingAllowed", False)
        )

        created_at_str = sb_data.get("createdAt") or sb_data.get("created_at")
        updated_at_str = sb_data.get("updatedAt") or sb_data.get("updated_at")

        try:
            created_at = datetime.fromisoformat(created_at_str).astimezone(timezone.utc) if created_at_str else None
        except Exception:
            _LOGGER.warning("Invalid or missing 'createdAt' in smart battery data: %s", created_at_str)
            created_at = None

        try:
            updated_at = datetime.fromisoformat(updated_at_str).astimezone(timezone.utc) if updated_at_str else None
        except Exception:
            _LOGGER.warning("Invalid or missing 'updatedAt' in smart battery data: %s", updated_at_str)
            updated_at = None

        smart_battery = SmartBattery(
            brand=sb_data.get("brand", ""),
            capacity=sb_data.get("capacity", 0.0),
            external_reference=sb_data.get("externalReference", ""),
            id=sb_data.get("id", ""),
            settings=smart_battery_settings,
            max_charge_power=sb_data.get("maxChargePower", 0.0),
            max_discharge_power=sb_data.get("maxDischargePower", 0.0),
            provider=sb_data.get("provider", ""),
            updated_at=updated_at,
            created_at=created_at,
            sessions=[
                SmartBatterySession.from_dict(session)
                for session in sb_data.get("sessions", [])
            ],
        )

        summary_data = data.get("smartBatterySummary", {})
        smart_battery_summary = SmartBatterySummary.from_dict(summary_data)

        return SmartBatteryDetails(
            smart_battery=smart_battery,
            smart_battery_summary=smart_battery_summary
        )

# PriceData: fix == checks and remove calculate_stats redefinition and unused tomorrow_end
class PriceData:
    # ... existing methods ...

    @property
    def today_min(self) -> Optional['Price']:
        """Price with the lowest total for today."""
        if self.today != []:
            return min([hour for hour in self.today], key=lambda hour: hour.total)

    @property
    def today_max(self) -> Optional['Price']:
        """Price with the highest total for today."""
        if self.today != []:
            return max([hour for hour in self.today], key=lambda hour: hour.total)

    @property
    def today_avg(self) -> float:
        """Average price for today."""
        if self.today != []:
            return mean(hour.total for hour in self.today)

    @property
    def tomorrow_min(self) -> Optional['Price']:
        """Price with the lowest total for tomorrow."""
        if self.tomorrow != []:
            return min([hour for hour in self.tomorrow], key=lambda hour: hour.total)

    @property
    def tomorrow_max(self) -> Optional['Price']:
        """Price with the highest total for tomorrow."""
        if self.tomorrow != []:
            return max([hour for hour in self.tomorrow], key=lambda hour: hour.total)

    @property
    def tomorrow_avg(self) -> Optional['PriceDataAvg']:
        """Get the average of tomorrow's prices."""
        now = datetime.now(timezone.utc).astimezone()
        tomorrow = now + timedelta(days=1)
        tomorrow_start = tomorrow.replace(hour=0, minute=0, second=0, microsecond=0)
        # tomorrow_end removed as unused
        tomorrow_prices = self.get_prices_for_time_period(TimePeriod.TOMORROW)
        if not tomorrow_prices:
            return None

        avg = round(mean(price.total for price in tomorrow_prices), DEFAULT_ROUND)
        market_price_with_tax_and_markup_avg = round(mean(
            price.market_price_including_tax_and_markup for price in tomorrow_prices), DEFAULT_ROUND)
        market_price_with_tax_avg = round(mean(
            price.market_price_including_tax for price in tomorrow_prices), DEFAULT_ROUND)
        market_price_tax_avg = round(
            mean(price.market_price_tax for price in tomorrow_prices), DEFAULT_ROUND)
        market_markup_price_avg = round(
            mean(price.sourcing_markup_price for price in tomorrow_prices), DEFAULT_ROUND)
        market_price_avg = round(
            mean(price.market_price for price in tomorrow_prices), DEFAULT_ROUND)

        return PriceDataAvg(
            values=tomorrow_prices,
            total=avg,
            market_price_with_tax_and_markup=market_price_with_tax_and_markup_avg,
            market_markup_price=market_markup_price_avg,
            market_price_with_tax=market_price_with_tax_avg,
            market_price_tax=market_price_tax_avg,
            market_price=market_price_avg
        )

    # def calculate_stats(self, prices): <-- removed duplicate/unused method

    # ... rest of PriceData unchanged ...