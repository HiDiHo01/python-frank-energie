1~
"""Data models enable parsing and processing of the Frank Energie API responses in a structured manner."""
2~
# python_frank_energie/models.py
3~

4~
import logging
5~
import statistics
6~
from collections import defaultdict, namedtuple
7~
from dataclasses import dataclass, field
8~
from datetime import date, datetime, timedelta, timezone, tzinfo
9~
from statistics import mean
10~
from typing import Iterator, Optional, Set, Union
11~

12~
import jwt
13~
import pytz
14~

15~
from jwt.exceptions import InvalidTokenError
16~
from dateutil.parser import parse
17~
from pydantic import BaseModel, EmailStr
18~

19~
from .exceptions import AuthException, RequestException
20~
from .time_periods import TimePeriod
21~

22~
DEFAULT_ROUND = 6
23~

24~
_LOGGER: logging.Logger = logging.getLogger(__name__)
25~

26~
VERSION = "2025.5.23"
27~
FETCH_TOMORROW_HOUR_UTC = 12
28~

29~
@dataclass
30~
class Authentication:
31~
    """Authentication data.
32~

33~
    Generated by the login or renewToken mutation.
34~

35~
    authToken: The token to use for authenticated requests.
36~
    refreshToken: The token to use to renew the authToken.
37~
    """
38~

39~
    authToken: str
40~
    refreshToken: str
41~
    expires_at: datetime | None = None
42~

43~
    @staticmethod
44~
    def from_dict(data: dict[str, str]) -> 'Authentication':
45~
        """Parse the response from the login or renewToken mutation."""
46~
        _LOGGER.debug("Authentication %s", data)
47~

48~
        if errors := data.get("errors"):
49~
            raise AuthException(errors[0]["message"])
50~

51~
        login_payload = data.get("data", {}).get("login")
52~
        renew_payload = data.get("data", {}).get("renewToken")
53~
        if not login_payload and not renew_payload:
54~
            raise AuthException("Unexpected response")
55~

56~
        payload = Authentication._extract_payload(data)
57~
        if not payload:
58~
            raise AuthException("Unexpected response")
59~

60~
        _LOGGER.debug("Authentication payload: %s", payload)
61~
        auth_token = payload.get("authToken")
62~
        refresh_token = payload.get("refreshToken")
63~

64~
        expires_at = None
65~
        if auth_token:
66~
            try:
67~
                decoded = jwt.decode(
68~
                    auth_token,
69~
                    options={"verify_signature": False},
70~
                    algorithms=["HS256"],
71~
                )
72~
                _LOGGER.debug("authToken decoded claims: %s", decoded)
73~
                exp_ts = decoded.get("exp")
74~
                if exp_ts:
75~
                    expires_at = datetime.fromtimestamp(exp_ts, tz=timezone.utc)
76~
                else:
77~
                    _LOGGER.warning("authToken missing 'exp' claim; treating as expired")
78~
                    expires_at = None
79~
                _LOGGER.debug("authToken expires at: %s", expires_at)
80~
            except InvalidTokenError as err:
81~
                _LOGGER.warning("Unable to decode authToken to extract expiration: %s", err)
82~

83~
        return Authentication(
84~
            authToken=auth_token,
85~
            refreshToken=refresh_token,
86~
            expires_at=expires_at,
87~
        )
88~

89~
    @staticmethod
90~
    def _extract_payload(data: dict) -> Optional[dict]:
91~
        """Extract the login or renewToken payload from the data dictionary."""
92~
        return data.get("data", {}).get("login") or data.get("data", {}).get("renewToken")
93~

94~
    def old_authTokenValid(self, tz: timezone = timezone.utc) -> bool:
95~
        """Return that authToken is valid according to expiration time."""
96~
        authTokenDecoded = jwt.decode(
97~
            self.authToken,
98~
            verify=True,
99~
            algorithms=["HS256"],
100~
            options={"verify_signature": False},
101~
        )
102~
        return datetime.fromtimestamp(
103~
            authTokenDecoded["exp"], tz=timezone.utc
104~
        ) > datetime.now(tz=tz)
105~

106~
    def old_auth_token_valid(self, tz: tzinfo = timezone.utc) -> bool:
107~
        """
108~
        Check if the authToken is still valid based on its expiration timestamp.
109~

110~
        Args:
111~
            tz (tzinfo): The timezone to compare the expiration against. Defaults to UTC.
112~

113~
        Returns:
114~
            bool: True if the token is still valid, False otherwise.
115~

116~
        Raises:
117~
            ValueError: If the authToken is missing or malformed.
118~
        """
119~
        if not self.authToken:
120~
            raise ValueError("authToken is missing or not set.")
121~

122~
        try:
123~
            auth_token_decoded = jwt.decode(
124~
                self.authToken,
125~
                options={"verify_signature": False},
126~
                algorithms=["HS256"],
127~
            )
128~
        except InvalidTokenError as err:
129~
            _LOGGER.warning("Failed to decode authToken: %s", err)
130~
            raise ValueError("Malformed authToken.") from err
131~

132~
        expiration = datetime.fromtimestamp(auth_token_decoded.get("exp", 0), tz=timezone.utc)
133~
        return expiration > datetime.now(tz=tz)
134~

135~
    @property
136~
    def is_expired(self) -> bool:
137~
        """Check if the token is expired based on the expires_at field."""
138~
        return not self.expires_at or datetime.now(timezone.utc) >= self.expires_at
139~

140~
@dataclass
141~
class Invoice:
142~
    """Represents invoice information, including the start date, period
143~
    description, and total amount."""
144~

145~
    StartDate: datetime
146~
    PeriodDescription: str
147~
    TotalAmount: float
148~

149~
    @property
150~
    def for_last_year(self) -> bool:
151~
        """Whether this invoice is for the current year."""
152~
        last_year = datetime.now(pytz.timezone('Europe/Amsterdam')).year-1
153~
        invoice_start_date_utc = self.StartDate.replace(tzinfo=pytz.UTC)
154~
        invoice_start_year = invoice_start_date_utc.astimezone(
155~
            pytz.timezone('Europe/Amsterdam')).year
156~
        return invoice_start_year == last_year
157~

158~
    @property
159~
    def for_this_year(self) -> bool:
160~
        """Whether this invoice is for the current year."""
161~
        current_year = datetime.now(
162~
            pytz.timezone('Europe/Amsterdam')).year
163~
        invoice_start_date_utc = self.StartDate.replace(tzinfo=pytz.UTC)
164~
        invoice_start_year = invoice_start_date_utc.astimezone(
165~
            pytz.timezone('Europe/Amsterdam')).year
166~
        return invoice_start_year == current_year
167~

168~
    @staticmethod
169~
    def from_dict(data: dict[str, object]) -> Optional['Invoice']:
170~
        """Parse the response from the invoice query."""
171~
        if data is None:
172~
            return None
173~

174~
        if isinstance(data, list):
175~
            return [Invoice.from_dict(item) for item in data]
176~

177~
        return Invoice(
178~
            StartDate=parse(data.get("StartDate")).astimezone(
179~
                pytz.timezone('Europe/Amsterdam')),
180~
            PeriodDescription=data.get("PeriodDescription"),
181~
            TotalAmount=float(data.get("TotalAmount")),
182~
        )
183~

184~

185~
@dataclass
186~
class Invoices:
187~
    """Represents invoices including historical, current, and upcoming periods."""
188~

189~
    def __init__(
190~
        self,
191~
        allPeriodsInvoices: Optional[list[Invoice]
192~
                                     ] = field(default_factory=list),
193~
        previousPeriodInvoice: Optional[Invoice] = None,
194~
        currentPeriodInvoice: Optional[Invoice] = None,
195~
        upcomingPeriodInvoice: Optional[Invoice] = None,
196~
        AllInvoicesDictForPreviousYear: dict = field(default_factory=dict),
197~
        AllInvoicesDictForThisYear: dict = field(default_factory=dict),
198~
        AllInvoicesDict: dict = field(default_factory=dict),
199~
        TotalCostsPreviousYear: float = 0.0,
200~
        TotalCostsThisYear: float = 0.0,
201~
    ):
202~
        self.allPeriodsInvoices = allPeriodsInvoices
203~
        self.previousPeriodInvoice = previousPeriodInvoice
204~
        self.currentPeriodInvoice = currentPeriodInvoice
205~
        self.upcomingPeriodInvoice = upcomingPeriodInvoice
206~
        self.AllInvoicesDictForPreviousYear = AllInvoicesDictForPreviousYear
207~
        self.AllInvoicesDictForThisYear = AllInvoicesDictForThisYear
208~
        self.AllInvoicesDict = AllInvoicesDict
209~
        self.TotalCostsPreviousYear = TotalCostsPreviousYear
210~
        self.TotalCostsThisYear = TotalCostsThisYear
211~

212~
    def get_all_invoices_dict_for_previous_year(self) -> dict:
213~
        """Retrieve all invoices for the specified year as a dictionary."""
214~
        previous_year = datetime.now(timezone.utc).year-1
215~
        invoices_dict = {}
216~

217~
        for invoice in self.get_invoices_for_year(previous_year):
218~
            if invoice.PeriodDescription in invoices_dict:
219~
                invoices_dict[invoice.PeriodDescription]["Total amount"] += invoice.TotalAmount
220~
            else:
221~
                invoices_dict[invoice.PeriodDescription] = {
222~
                    "Start date": invoice.StartDate.astimezone(pytz.timezone('Europe/Amsterdam')),
223~
                    "Period description": invoice.PeriodDescription,
224~
                    "Total amount": invoice.TotalAmount
225~
                }
226~

227~
        return invoices_dict
228~

229~
    def get_all_invoices_dict_for_this_year(self) -> dict:
230~
        """Retrieve all invoices for the specified year as a dictionary."""
231~
        current_year = datetime.now(timezone.utc).year
232~
        invoices_dict = {}
233~

234~
        for invoice in self.get_invoices_for_year(current_year):
235~
            if invoice.PeriodDescription in invoices_dict:
236~
                invoices_dict[invoice.PeriodDescription]["Total amount"] += invoice.TotalAmount
237~
            else:
238~
                invoices_dict[invoice.PeriodDescription] = {
239~
                    "Start date": invoice.StartDate.astimezone(pytz.timezone('Europe/Amsterdam')),
240~
                    "Period description": invoice.PeriodDescription,
241~
                    "Total amount": invoice.TotalAmount
242~
                }
243~

244~
        return invoices_dict
245~

246~
    def get_all_invoices_dict_per_year(self) -> dict:
247~
        """Calculate totals per year and return as a dictionary."""
248~
        all_invoices_dict = defaultdict(lambda: {"Total amount": 0.0})
249~

250~
        for invoice in self.allPeriodsInvoices:
251~
            year = invoice.StartDate.year
252~
            all_invoices_dict[year]["Start date"] = invoice.StartDate.astimezone(
253~
                pytz.timezone('Europe/Amsterdam'))
254~
            all_invoices_dict[year]["Period description"] = f"Total for {year}"
255~
            all_invoices_dict[year]["Total amount"] += invoice.TotalAmount
256~

257~
        return dict(all_invoices_dict)
258~

259~
    def get_all_invoices_dict(self) -> dict:
260~
        """Retrieve all invoices as a dictionary and sum duplicates."""
261~
        invoices_dict = {}
262~

263~
        sorted_invoices = sorted(
264~
            self.allPeriodsInvoices, key=lambda invoice: invoice.StartDate)
265~

266~
        for invoice in sorted_invoices:
267~
            if invoice.PeriodDescription in invoices_dict:
268~
                invoices_dict[invoice.PeriodDescription]["Total amount"] += invoice.TotalAmount
269~
            else:
270~
                invoices_dict[invoice.PeriodDescription] = {
271~
                    "Start date": invoice.StartDate.astimezone(pytz.timezone('Europe/Amsterdam')),
272~
                    "Period description": invoice.PeriodDescription,
273~
                    "Total amount": invoice.TotalAmount
274~
                }
275~

276~
        return invoices_dict
277~

278~
    def get_invoices_for_year(self, year: int) -> list['Invoice']:
279~
        """Filter invoices based on the specified year, considering timezone difference."""
280~
        europe_amsterdam_timezone = pytz.timezone('Europe/Amsterdam')
281~
        start_of_year_utc2 = europe_amsterdam_timezone.localize(
282~
            datetime(year, 1, 1, 0, 0, 0))
283~
        end_of_year_utc2 = start_of_year_utc2.replace(
284~
            month=12, day=31, hour=23, minute=59, second=59)
285~

286~
        filtered_invoices = [
287~
            invoice for invoice in self.allPeriodsInvoices
288~
            if invoice.StartDate >= start_of_year_utc2.astimezone(pytz.UTC) and
289~
            invoice.StartDate <= end_of_year_utc2.astimezone(pytz.UTC)
290~
        ]
291~

292~
        filtered_invoices.sort(key=lambda invoice: invoice.StartDate)
293~
        return filtered_invoices
294~

295~
    def calculate_total_costs(self, year: int) -> float:
296~
        """Calculate the total costs for the specified year using allPeriodsInvoices."""
297~
        return sum(invoice.TotalAmount for invoice in self.get_invoices_for_year(year))
298~

299~
    def calculate_average_costs_per_month(self, year: int = None) -> Optional[float]:
300~
        """Calculate the average costs per month."""
301~
        if year is None:
302~
            invoices = self.allPeriodsInvoices
303~
        else:
304~
            invoices = self.get_invoices_for_year(year)
305~

306~
        invoices_count = 0
307~
        total_costs = 0.0
308~
        unique_months = set()
309~

310~
        for invoice in invoices:
311~
            # Set invoice to PeriodDescription
312~
            invoice_month = invoice.PeriodDescription
313~

314~
            # Check if the month has already been counted
315~
            # Do not count duplicate invoices and invoices with " tot " in the PeriodDescription
316~
            if invoice_month not in unique_months and " tot " not in invoice_month:
317~
                # ensure that we only count each month once.
318~
                invoices_count += 1
319~
                unique_months.add(invoice_month)
320~

321~
            total_costs += invoice.TotalAmount
322~

323~
        if invoices_count == 0:
324~
            return None
325~

326~
        average_costs = total_costs / invoices_count
327~

328~
        return average_costs
329~

330~
    def calculate_expected_costs_this_year(self) -> Optional[float]:
331~
        """Calculate the expected costs for the current year."""
332~
        current_year = datetime.now().year
333~

334~
        # Calculate the average costs per month for the current year
335~
        average_costs_per_month = self.calculate_average_costs_per_month(
336~
            year=current_year)
337~

338~
        if average_costs_per_month is None:
339~
            return None
340~

341~
        # Multiply the average costs per month by 12 to get the expected costs for the year
342~
        expected_costs_this_year = average_costs_per_month * 12
343~

344~
        return expected_costs_this_year
345~

346~
    def get_unique_years(self) -> Set[int]:
347~
        """Get the unique years present in allPeriodsInvoices."""
348~
        unique_years = {
349~
            invoice.StartDate.year for invoice in self.allPeriodsInvoices}
350~
        return unique_years
351~

352~
    def calculate_average_costs_per_year(self) -> Optional[float]:
353~
        """Calculate the average costs for the specified year."""
354~
        invoices = self.allPeriodsInvoices
355~

356~
        if not invoices:
357~
            return None
358~

359~
        total_costs = sum(invoice.TotalAmount for invoice in invoices)
360~
        unique_years_count = len(self.get_unique_years())
361~

362~
        # Avoid division by zero
363~
        if unique_years_count == 0:
364~
            return None
365~

366~
        average_costs = total_costs / unique_years_count
367~

368~
        return average_costs
369~

370~
    def calculate_average_costs_per_month_this_year(self) -> Optional[float]:
371~
        """Calculate the average costs per month for this year."""
372~
        invoices_count = 0
373~
        total_costs = 0.0
374~

375~
        current_year = datetime.now(timezone.utc).year
376~

377~
        for invoice in self.allPeriodsInvoices:
378~
            if invoice.StartDate.year == current_year:
379~
                if " tot " not in invoice.PeriodDescription:
380~
                    invoices_count += 1
381~
                    total_costs += invoice.TotalAmount
382~
                else:
383~
                    total_costs += invoice.TotalAmount
384~

385~
        if invoices_count == 0:
386~
            return None
387~

388~
        current_month = datetime.now(timezone.utc).month
389~
        average_costs = total_costs / invoices_count
390~

391~
        if current_month == 1:
392~
            # Handle January case, as it's the first month of the year
393~
            average_costs *= 12
394~
        else:
395~
            average_costs *= 12 / current_month
396~

397~
        return average_costs
398~

399~
    @staticmethod
400~
    def from_dict(data: dict[str, object]) -> 'Invoices':
401~
        """Parse the response from the invoices query."""
402~
        _LOGGER.debug("Invoices %s", data)
403~

404~
        if errors := data.get("errors"):
405~
            raise RequestException(errors[0]["message"])
406~

407~
        payload = data.get("data", {}).get("invoices")
408~
        if not payload:
409~
            raise RequestException("Unexpected response")
410~

411~
        invoices_instance = Invoices(
412~
            allPeriodsInvoices=Invoice.from_dict(
413~
                payload.get("allInvoices")
414~
            ),
415~
            previousPeriodInvoice=Invoice.from_dict(
416~
                payload.get("previousPeriodInvoice")
417~
            ),
418~
            currentPeriodInvoice=Invoice.from_dict(
419~
                payload.get("currentPeriodInvoice")
420~
            ),
421~
            upcomingPeriodInvoice=Invoice.from_dict(
422~
                payload.get("upcomingPeriodInvoice")
423~
            ),
424~
        )
425~

426~
        current_year = datetime.now(timezone.utc).year
427~
        previous_year = current_year - 1
428~

429~
        invoices_instance.TotalCostsPreviousYear = invoices_instance.calculate_total_costs(
430~
            previous_year)
431~
        invoices_instance.TotalCostsThisYear = invoices_instance.calculate_total_costs(
432~
            current_year)
433~
        invoices_instance.AllInvoicesDictForPreviousYear = invoices_instance.get_all_invoices_dict_for_previous_year()
434~
        invoices_instance.AllInvoicesDictForThisYear = invoices_instance.get_all_invoices_dict_for_this_year()
435~
        invoices_instance.AllInvoicesDict = invoices_instance.get_all_invoices_dict()
436~
        return invoices_instance
437~

438~
@dataclass
439~
class UsageItem:
440~
    """Representeert een individueel gebruiksitem binnen een periode."""
441~

442~
    date: str
443~
    from_time: str
444~
    till_time: str
445~
    usage: float
446~
    costs: float
447~
    unit: str
448~

449~
    @staticmethod
450~
    def from_dict(data: dict[str, object]) -> 'UsageItem':
451~
        """Maakt een UsageItem-object aan vanuit een dictionary."""
452~
        try:
453~
            return UsageItem(
454~
                date=str(data["date"]),
455~
                from_time=str(data["from"]),
456~
                till_time=str(data["till"]),
457~
                usage=float(data["usage"]),
458~
                costs=float(data["costs"]),
459~
                unit=str(data["unit"]),
460~
            )
461~
        except KeyError as e:
462~
            raise ValueError(f"Ontbrekend veld {e.args[0]} in UsageItem data: {data}") from e
463~
        except (ValueError, TypeError) as e:
464~
            raise ValueError(f"Fout bij conversie van UsageItem data: {e}, data: {data}") from e
465~

466~

467~
@dataclass
468~
class EnergyCategory:
469~
    """Representeert een energiecategorie zoals gas, elektriciteit of teruglevering."""
470~

471~
    usage_total: float
472~
    costs_total: float
473~
    unit: str
474~
    items: list[UsageItem]
475~
    # costs_this_month: float = 0.0
476~

477~
    @staticmethod
478~
    def from_dict(data: dict[str, object]) -> 'EnergyCategory':
479~
        """Creates an EnergyCategory object from a dictionary."""
480~
        _LOGGER.debug("EnergyCategory.from_dict() called with data: %s", data)
481~
        try:
482~
            if data is None:
483~
                # return EnergyCategory(usage_total=0.00, costs_total=0.00, unit="", items=[])
484~
                # TODO: Check if this is the correct behavior
485~
                return None
486~

487~
            usage_total = float(data["usageTotal"]) if data.get("usageTotal") is not None else 0.00
488~
            costs_total = float(data["costsTotal"]) if data.get("costsTotal") is not None else 0.00
489~

490~
            return EnergyCategory(
491~
                usage_total=usage_total,
492~
                costs_total=costs_total,
493~
                unit=str(data["unit"]),
494~
                items=[UsageItem.from_dict(item) for item in data.get("items", []) or []],
495~
            )
496~
        except KeyError as e:
497~
            raise ValueError(f"Missing field {e.args[0]} in EnergyCategory data: {data}") from e
498~
        except (ValueError, TypeError) as e:
499~
            raise ValueError(f"Error converting EnergyCategory data: {e}, data: {data}") from e
500~

501~
@dataclass
502~
class PeriodUsageAndCosts:
503~
    """Bevat het verbruik en de kosten van gas, elektriciteit en teruglevering voor een periode."""
504~

505~
    _id: str
506~
    gas: Optional[EnergyCategory]
507~
    electricity: Optional[EnergyCategory]
508~
    feed_in: Optional[EnergyCategory]
509~

510~
    @staticmethod
511~
    def from_dict(data: dict[str, object]) -> 'PeriodUsageAndCosts':
512~
        """Maakt een PeriodUsageAndCosts-object aan vanuit een dictionary."""
513~
        try:
514~
            input_data = data.get("data")
515~
            period_data = input_data.get("periodUsageAndCosts")
516~
            if not period_data:
517~
                return None
518~

519~
            # Handle cases where gas, electricity, or feed_in data is None
520~
            gas_data = period_data.get("gas") if period_data.get("gas") is not None else None
521~
            feed_in_data = period_data.get("feedIn") if period_data.get("feedIn") is not None else None
522~
            electricity_data = period_data.get("electricity") if period_data.get("electricity") is not None else None
523~

524~
            # Return None if gas data is None
525~
            # if gas_data is None:
526~
            #    return None
527~

528~
            # If any of the required data is missing, the field will be set to None
529~
            return PeriodUsageAndCosts(
530~
                _id=str(period_data["_id"]),
531~
                gas=EnergyCategory.from_dict(gas_data) if gas_data else None,
532~
                electricity=EnergyCategory.from_dict(electricity_data) if electricity_data else None,
533~
                feed_in=EnergyCategory.from_dict(feed_in_data) if feed_in_data else None,
534~
            )
535~
        except KeyError as e:
536~
            raise ValueError(f"Ontbrekend veld {e.args[0]} in PeriodUsageAndCosts data: {data}") from e
537~
        except (ValueError, TypeError) as e:
538~
            raise ValueError(f"Fout bij conversie van PeriodUsageAndCosts data: {e}, data: {data}") from e
539~

540~
@dataclass
541~
class UserSites:
542~
    """UserSites data."""
543~

544~
    deliverySites: list[object]
545~
    addressFormatted: str
546~
    addressHasMultipleSites: bool
547~
    deliveryEndDate: Optional[str]
548~
    deliveryStartDate: Optional[str]
549~
    firstMeterReadingDate: Optional[str]
550~
    lastMeterReadingDate: Optional[str]
551~
    propositionType: Optional[str]
552~
    reference: str
553~
    segments: list[str]
554~
    status: str
555~

556~
    @staticmethod
557~
    def from_dict(data: dict[str, str]) -> 'UserSites':
558~
        """Parse the response from the UserSites query."""
559~
        _LOGGER.debug("UserSites %s", data)
560~

561~
        if errors := data.get("errors"):
562~
            raise RequestException(errors[0]["message"])
563~

564~
        if 'errors' in data:
565~
            raise RequestException(data['errors'][0]['message'])
566~

567~
        user_sites = data.get("data", {}).get("userSites")
568~
        if not user_sites or not isinstance(user_sites, list):
569~
            raise RequestException("Unexpected response format for userSites")
570~

571~
        first_meter_reading_date: Optional[str] = None
572~
        last_meter_reading_date: Optional[str] = None
573~
        if user_sites and isinstance(user_sites, list):
574~
            first_site = user_sites[0]
575~
            first_meter_reading_date = first_site.get("firstMeterReadingDate")
576~
            last_meter_reading_date = first_site.get("lastMeterReadingDate")
577~

578~
        return UserSites(
579~
            addressFormatted=first_site.get("addressFormatted"),
580~
            addressHasMultipleSites=first_site.get("addressHasMultipleSites"),
581~
            deliveryEndDate=first_site.get("deliveryEndDate"),
582~
            deliveryStartDate=first_site.get("deliveryStartDate"),
583~
            firstMeterReadingDate=first_meter_reading_date,
584~
            lastMeterReadingDate=last_meter_reading_date,
585~
            propositionType=first_site.get("propositionType"),
586~
            reference=first_site.get("reference"),
587~
            segments=first_site.get("segments"),
588~
            status=first_site.get("status"),
589~
            # deliverySites=DeliverySiteList(payload.get("deliverySites")),
590~
            # deliverySites=DeliverySiteList(delivery_sites_data),
591~
            deliverySites=[
592~
                DeliverySite.from_dict(site) for site in user_sites
593~
            ] if 'DeliverySite' in globals() else [],
594~
        )
595~

596~
    @property
597~
    def old_format_delivery_site_as_dict(self):
598~
        sites_as_dict = []
599~
        for site in self.deliverySites:
600~
            address = site.get('address', {})
601~
            sites_as_dict.append(
602~
                f"{address.get('street')} {address.get('houseNumber')} {address.get('houseNumberAddition', '') if address.get('houseNumberAddition') else ''} {address.get('zipCode')} {address.get('city')}")
603~
        return sites_as_dict
604~

605~
    @property
606~
    def old2_format_delivery_site_as_dict(self) -> list[str]:
607~
        """Format delivery site information as a list of formatted addresses."""
608~
        sites_as_dict = []
609~
        for site in self.deliverySites:
610~
            address = getattr(site, 'address', {})
611~
            sites_as_dict.append(
612~
                f"{address.get('street', '')} {address.get('houseNumber', '')} "
613~
                f"{address.get('houseNumberAddition', '') if address.get('houseNumberAddition') else ''} "
614~
                f"{address.get('zipCode', '')} {address.get('city', '')}".strip()
615~
            )
616~
        return sites_as_dict
617~

618~
    @property
619~
    def format_delivery_site_as_dict(self) -> list[str]:
620~
        """Format delivery site information as a list of formatted addresses."""
621~
        sites_as_dict = []
622~
        for site in self.deliverySites:
623~
            address = getattr(site, 'address', None)
624~

625~
            if address:
626~
                sites_as_dict.append(
627~
                    f"{getattr(address, 'street', '')} {getattr(address, 'houseNumber', '')} "
628~
                    f"{getattr(address, 'houseNumberAddition', '') if getattr(address, 'houseNumberAddition', None) else ''} "
629~
                    f"{getattr(address, 'zipCode', '')} {getattr(address, 'city', '')}".strip()
630~
                )
631~
        return sites_as_dict
632~

633~

634~
@dataclass
635~
class Me:
636~
    """Me data, including the current status of the connection."""
637~

638~
    id: str
639~
    email: str
640~
    countryCode: str
641~
    segments: list[str]
642~
    advancedPaymentAmount: float
643~
    treesCount: int
644~
    hasInviteLink: bool
645~
    hasCO2Compensation: bool
646~
    updatedAt: str
647~
    addressHasMultipleSites: bool
648~
    meterReadingExportPeriods: list['MeterReadingExportPeriod']
649~
    smartCharging: dict
650~

651~
    @staticmethod
652~
    def from_dict(data: dict[str, str]) -> 'Me':
653~
        """Parse the response from the me query."""
654~
        _LOGGER.debug("User %s", data)
655~

656~
        if errors := data.get("errors"):
657~
            raise RequestException(errors[0]["message"])
658~

659~
        if 'errors' in data:
660~
            raise RequestException(data['errors'][0]['message'])
661~

662~
        payload = data.get("data", {}).get("me")
663~
        if not payload:
664~
            raise RequestException("Unexpected response")
665~

666~
        return Me(
667~
            id=payload.get("id"),
668~
            email=payload.get("email"),
669~
            countryCode=payload.get("countryCode"),
670~
            segments=payload.get("segments"),
671~
            advancedPaymentAmount=payload.get("advancedPaymentAmount"),
672~
            treesCount=payload.get("treesCount"),
673~
            hasInviteLink=payload.get("hasInviteLink"),
674~
            hasCO2Compensation=payload.get("hasCO2Compensation"),
675~
            updatedAt=payload.get("updatedAt"),
676~
            addressHasMultipleSites=payload.get("addressHasMultipleSites"),
677~
            meterReadingExportPeriods=payload.get("meterReadingExportPeriods"),
678~
            smartCharging=payload.get("smartCharging"),
679~
        )
680~

681~

682~
def get_segments(data: dict[str, object]) -> Optional[list[str]]:
683~
    delivery_site_data = data.get("user")
684~
    if delivery_site_data:
685~
        delivery_site = DeliverySite(**delivery_site_data)
686~
        return delivery_site.segments
687~
    return None
688~

689~

690~
@dataclass
691~
class Address:
692~
    """Address of the delivery site."""
693~
    street: str
694~
    houseNumber: str
695~
    zipCode: str
696~
    city: str
697~
    houseNumberAddition: Optional[str] = field(default=None)
698~

699~
    @staticmethod
700~
    def from_dict(data: dict[str, object]) -> "Address":
701~
        # address_formatted = data.get("addressFormatted", ["", ""])
702~
        address_formatted = data.get("addressFormatted")
703~
        if not address_formatted or len(address_formatted) < 2:
704~
            # Handle lege of ontbrekende waarde
705~
            # print("Invalid address: address is missing or too short")
706~
            return None
707~
            # raise ValueError("Invalid address: address is missing or too short")
708~
        # Eerste deel bevat straat en huisnummer (bijv. "Straat 123")
709~
        street_and_number = address_formatted[0]
710~
        postcode_and_city = address_formatted[1]
711~
        street_parts = street_and_number.rsplit(" ", 1)
712~
        street = street_parts[0]
713~
        # Tweede deel bevat postcode en stad (bijv. "1000 AA AMSTERDAM")
714~
        zip_city_parts = postcode_and_city.split(" ", 2)
715~
        zip_code = " ".join(zip_city_parts[:2])
716~
        city = zip_city_parts[2] if len(zip_city_parts) > 2 else ""
717~
        house_number_addition = None
718~
        house_number = street_parts[1] if len(street_parts) > 1 else ""
719~
        if not house_number.isdigit():  # Als er letters in staan, splitsen
720~
            for i, char in enumerate(house_number):
721~
                if char.isalpha():
722~
                    house_number_addition = house_number[i:]
723~
                    house_number = house_number[:i]
724~
                    break
725~
        return Address(
726~
            street=street,
727~
            houseNumber=house_number,
728~
            zipCode=zip_code,
729~
            city=city,
730~
            houseNumberAddition=house_number_addition
731~
        )
732~

733~
# @dataclass
734~

735~

736~
class DeliverySite(BaseModel):
737~
    """Delivery sites data, including the address and delivery status.
738~

739~
    {
740~
        "reference": "1082MK 10",
741~
        "segments": [
742~
            "ELECTRICITY",
743~
            "GAS"
744~
        ],
745~
        "address": {
746~
            "street": "Gustav Mahlerlaan",
747~
            "houseNumber": "1025",
748~
            "houseNumberAddition": null,
749~
            "zipCode": "1082 MK",
750~
            "city": "AMSTERDAM"
751~
        },
752~
        "addressHasMultipleSites": false,
753~
        "status": "DELIVERY_ENDED",
754~
        "propositionType": null,
755~
        "deliveryStartDate": "2023-01-05",
756~
        "deliveryEndDate": "2024-02-09",
757~
        "firstMeterReadingDate": "2023-01-05",
758~
        "lastMeterReadingDate": "2024-02-08"
759~
    },
760~
    """
761~
    addressHasMultipleSites: bool
762~
    propositionType: Optional[str]
763~
    reference: str
764~
    segments: list[str]
765~
    address: Address
766~
    status: str
767~
    deliveryStartDate: Optional[date]
768~
    deliveryEndDate: Optional[date] = None
769~
    firstMeterReadingDate: Optional[date]
770~
    lastMeterReadingDate: Optional[date]
771~

772~
    @staticmethod
773~
    def from_dict(payload: dict[str, str]) -> 'DeliverySite':
774~
        """Parse the response from the me query."""
775~

776~
        if not payload:
777~
            return None
778~

779~
        _LOGGER.debug("DeliverySites %s", payload)
780~

781~
        # address_data = payload.get("addressFormatted")
782~
        # address_data = payload.get("addressFormatted", ["", ""])
783~
        # address = Address(**address_data) if address_data else None
784~
        address_data = payload.get("address")
785~
        address = Address.from_dict(address_data) if address_data else None
786~

787~
        return DeliverySite(
788~
            reference=payload.get("reference"),
789~
            segments=payload.get("segments", []),
790~
            addressHasMultipleSites=payload.get(
791~
                "addressHasMultipleSites", False),
792~
            address=address,
793~
            propositionType=payload.get("propositionType"),
794~
            status=payload.get("status"),
795~
            deliveryStartDate=(
796~
                datetime.strptime(payload.get("deliveryStartDate"), "%Y-%m-%d").date()
797~
                if payload.get("deliveryStartDate") else None
798~
            ),
799~
            deliveryEndDate=(
800~
                datetime.strptime(payload.get("deliveryEndDate"), "%Y-%m-%d").date()
801~
                if payload.get("deliveryEndDate") else None
802~
            ),
803~
            firstMeterReadingDate=(
804~
                datetime.strptime(payload.get("firstMeterReadingDate"), "%Y-%m-%d").date()
805~
                if payload.get("firstMeterReadingDate") else None
806~
            ),
807~
            lastMeterReadingDate=(
808~
                datetime.strptime(payload.get("lastMeterReadingDate"), "%Y-%m-%d").date()
809~
                if payload.get("lastMeterReadingDate") else None
810~
            )
811~
        ) if payload else None
812~

813~
    @property
814~
    def format_delivery_site_as_dict(self):
815~
        sites_as_dict = []
816~
        for site in self.deliverySites:
817~
            address = site.get('address', {})
818~
            sites_as_dict.append(
819~
                f"{address.get('street')} {address.get('houseNumber')} {address.get('houseNumberAddition', '') if address.get('houseNumberAddition') else ''} {address.get('zipCode')} {address.get('city')}")
820~
        return sites_as_dict
821~

822~
@dataclass
823~
class Person:
824~
    firstName: Optional[str] = None
825~
    lastName: Optional[str] = None
826~

827~
    @staticmethod
828~
    def from_dict(data: dict[str, object]) -> "Person":
829~
        return Person(
830~
            firstName=data.get("firstName"),
831~
            lastName=data.get("lastName")
832~
        )
833~

834~

835~
@dataclass
836~
class Contact:
837~
    emailAddress: Optional[EmailStr] = None
838~
    phoneNumber: Optional[str] = None
839~
    mobileNumber: Optional[str] = None
840~

841~
    @staticmethod
842~
    def from_dict(data: dict[str, object]) -> "Contact":
843~
        return Contact(
844~
            emailAddress=data.get("emailAddress"),
845~
            phoneNumber=data.get("phoneNumber"),
846~
            mobileNumber=data.get("mobileNumber")
847~
        )
848~

849~

850~
@dataclass
851~
class Email:
852~
    email: str
853~

854~

855~
@dataclass
856~
class Debtor:
857~
    bankAccountNumber: Optional[str] = None
858~
    preferredAutomaticCollectionDay: Optional[int] = None
859~

860~
    @staticmethod
861~
    def from_dict(data: dict[str, object]) -> "Debtor":
862~
        return Debtor(
863~
            bankAccountNumber=data.get("bankAccountNumber"),
864~
            preferredAutomaticCollectionDay=data.get(
865~
                "preferredAutomaticCollectionDay")
866~
        )
867~

868~

869~
@dataclass
870~
class GridOperatorAddress:
871~
    """Address of the grid operator."""
872~
    street: Optional[str] = None
873~
    houseNumber: Optional[str] = None
874~
    houseNumberAddition: Optional[str] = None
875~
    zipCode: Optional[str] = None
876~
    city: Optional[str] = None
877~

878~

879~
@dataclass
880~
class ExternalDetails:
881~
    """Details about the external grid operator."""
882~
    gridOperator: Optional[str] = None
883~
    address: GridOperatorAddress = field(default_factory=GridOperatorAddress)
884~

885~

886~
@dataclass
887~
class Connection:
888~
    """Represents a connection to the energy grid."""
889~
    id: Optional[str] = None
890~
    connectionId: Optional[str] = None
891~
    EAN: Optional[str] = None
892~
    segment: Optional[str] = None
893~
    status: Optional[str] = None
894~
    contractStatus: Optional[str] = None
895~
    estimatedFeedIn: Optional[float] = None
896~
    firstMeterReadingDate: Optional[str] = None
897~
    lastMeterReadingDate: Optional[str] = None
898~
    meterType: Optional[str] = None
899~
    externalDetails: ExternalDetails = field(default_factory=ExternalDetails)
900~

901~

902~
@dataclass
903~
class MeterReadingExportPeriod:
904~
    EAN: str
905~
    user: 'User'
906~
    cluster: str
907~
    createdAt: str
908~
    from_date: str
909~
    till_date: str
910~
    period: str
911~
    segment: str
912~
    type: str
913~
    updatedAt: str
914~

915~

916~
class UserDetails:
917~
    id: Optional[str] = None
918~
    email: Optional[str] = None
919~

920~

921~
@dataclass
922~
class Signup:
923~
    user: UserDetails
924~

925~

926~
@dataclass
927~
class UserSettings:
928~
    id: str
929~
    disabledHapticFeedback: bool
930~
    jedlixUserId: Optional[str]
931~
    jedlixPushNotifications: bool
932~
    smartPushNotifications: bool
933~
    rewardPayoutPreference: str
934~

935~

936~
@dataclass
937~
class activePaymentAuthorization:
938~
    """Represents an active payment authorization record."""
939~
    id: str
940~
    mandateId: str
941~
    signedAt: str
942~
    bankAccountNumber: str
943~
    status: str
944~

945~
    @staticmethod
946~
    def from_dict(data: dict) -> 'activePaymentAuthorization':
947~
        return activePaymentAuthorization(
948~
            id=data.get("id"),
949~
            mandateId=data.get("mandateId"),
950~
            signedAt=data.get("signedAt"),
951~
            bankAccountNumber=data.get("bankAccountNumber"),
952~
            status=data.get("status")
953~
        )
954~

955~

956~
@dataclass
957~
class InviteLinkUser:
958~
    awardRewardType: str
959~
    createdAt: str
960~
    description: Optional[str]
961~
    discountPerConnection: int
962~
    fromName: str
963~
    id: str
964~
    imageUrl: Optional[str]
965~
    slug: str
966~
    status: str
967~
    tintColor: Optional[str]
968~
    treesAmountPerConnection: int
969~
    type: str
970~
    updatedAt: str
971~
    usedCount: int
972~

973~

974~
@dataclass
975~
class Organization:
976~
    Email: str
977~

978~

979~
@dataclass
980~
class PushNotificationPriceAlert:
981~
    id: Optional[str] = None
982~
    isEnabled: Optional[bool] = None
983~
    type: Optional[str] = None
984~
    weekdays: Optional[list[int]] = None
985~

986~

987~
@dataclass
988~
class SmartCharging:
989~
    isActivated: Optional[bool] = None
990~
    provider: Optional[str] = None
991~
    userCreatedAt: Optional[str] = None
992~
    userId: Optional[str] = None
993~
    isAvailableInCountry: Optional[bool] = None
994~
    needsSubscription: Optional[bool] = None
995~
    subscription: Optional[str] = None
996~

997~

998~
@dataclass
999~
class SmartTrading:
1000~
    isActivated: Optional[bool] = None
1001~
    userCreatedAt: Optional[str] = None
1002~
    userId: Optional[str] = None
1003~
    isAvailableInCountry: Optional[bool] = None
1004~

1005~

1006~
@dataclass
1007~
class ExternalDetails:
1008~
    reference: Optional[str] = None
1009~
    person: Optional[Person] = None
1010~
    contact: Optional[Contact] = None
1011~
    address: Optional[Address] = None
1012~
    debtor: Optional[Debtor] = None
1013~

1014~
    @staticmethod
1015~
    def from_dict(data: dict[str, object]) -> "ExternalDetails":
1016~
        return ExternalDetails(
1017~
            reference=data.get("reference"),
1018~
            person=Person.from_dict(data.get("person", {})),
1019~
            contact=Contact.from_dict(data.get("contact", {})),
1020~
            address=Address.from_dict(data.get("address", {})),
1021~
            debtor=Debtor.from_dict(data.get("debtor", {}))
1022~
        )
1023~

1024~

1025~
@dataclass
1026~
class DeliverySiteFormat:
1027~
    """Formatted address of the delivery site."""
1028~
    address: Address
1029~

1030~
    def formatted_info(self) -> str:
1031~
        """Formatted address of the delivery site."""
1032~
        return f"{self.address.street} {self.address.houseNumber} {self.address.zipCode} {self.address.city}"
1033~

1034~

1035~
@dataclass
1036~
class DeliverySiteList:
1037~
    """List with delivery sites."""
1038~
    delivery_sites: list[DeliverySite]
1039~

1040~
    def __iter__(self):
1041~
        """Return an iterator over the delivery sites."""
1042~
        return iter(self.delivery_sites)
1043~

1044~
    def as_list(self) -> list[dict[str, str]]:
1045~
        """Convert the delivery sites to a list of dictionaries.
1046~

1047~
        Each dictionary represents the formatted information of a delivery site.
1048~

1049~
        Returns:
1050~
            A list of dictionaries representing the delivery sites.
1051~
        """
1052~
        sites = []
1053~
        for index, site in enumerate(self.delivery_sites, start=1):
1054~
            site_name = f"Delivery site {index}"
1055~
            site_info = {site_name: site.formatted_info()}
1056~
            sites.append(site_info)
1057~
        return sites
1058~

1059~
    def as_dict(self) -> dict[str, dict]:
1060~
        """Convert the delivery sites to a dictionary of address information.
1061~

1062~
        Each key-value pair represents the site name and the corresponding address
1063~
        information of a delivery site.
1064~

1065~
        Returns:
1066~
            A dictionary where keys are site names and values are address information dictionaries.
1067~
        """
1068~
        site_dict = {}
1069~
        for index, site in enumerate(self.delivery_sites, start=1):
1070~
            site_name = f"Delivery site {index}"
1071~
            site_dict[site_name] = site.address.__dict__
1072~
        return site_dict
1073~

1074~

1075~
class DailyConsumption:
1076~
    def __init__(self, date: str, consumption_kwh: float):
1077~
        """
1078~
        Initialize a DailyConsumption instance.
1079~

1080~
        Parameters:
1081~
        - date (str): The date of the daily consumption.
1082~
        - consumption_kwh (float): The energy consumption in kilowatt-hours for the specified date.
1083~
        """
1084~
        self.date = date
1085~
        self.consumption_kwh = consumption_kwh
1086~

1087~

1088~
class EnergyConsumption:
1089~
    def __init__(self, user_id: str, daily_consumption: list[DailyConsumption]):
1090~
        """
1091~
        Initialize an EnergyConsumption instance.
1092~

1093~
        Parameters:
1094~
        - user_id (str): The unique identifier of the user.
1095~
        - daily_consumption (List[DailyConsumption]): A list of DailyConsumption instances representing daily energy consumption.
1096~
        """
1097~
        self.user_id = user_id
1098~
        self.daily_consumption = daily_consumption
1099~

1100~
    @classmethod
1101~
    def from_dict(cls, data: dict[str, object]) -> Optional['EnergyConsumption']:
1102~
        """
1103~
        Create an EnergyConsumption instance from a dictionary.
1104~

1105~
        Parameters:
1106~
        - data (Dict[str, Any]): The input dictionary containing user and energy consumption data.
1107~

1108~
        Returns:
1109~
        - EnergyConsumption: An instance of the EnergyConsumption class.
1110~
        """
1111~
        user_data = data.get("user", {})
1112~
        user_id = user_data.get("id")
1113~
        daily_consumption_data = user_data.get(
1114~
            "energyConsumption", {}).get("daily", [])
1115~

1116~
        daily_consumption = [
1117~
            DailyConsumption(date=item.get("date"),
1118~
                             consumption_kwh=item.get("consumptionKwh"))
1119~
            for item in daily_consumption_data
1120~
        ]
1121~

1122~
        return cls(user_id, daily_consumption)
1123~

1124~

1125~
@dataclass
1126~
class User:
1127~
    """User data, including the current status of the connection."""
1128~

1129~
    id: str
1130~
    PaymentAuthorizations: list
1131~
    activePaymentAuthorization: Optional[list]
1132~
    InviteLinkUser: InviteLinkUser
1133~
    Organization: Organization
1134~
    # deliverySites: DeliverySiteList
1135~
    connections: Optional[list[Connection]]
1136~
    # deliverySites: list[DeliverySite]
1137~
    createdAt: datetime
1138~
    updatedAt: datetime
1139~
    email: str
1140~
    # firstName: Optional[str]
1141~
    # lastName: Optional[str]
1142~
    countryCode: str
1143~
    # segments: list[str]
1144~
    lastLogin: datetime
1145~
    reference: int
1146~
    connectionsStatus: str
1147~
    # deliveryStartDate: date
1148~
    # firstMeterReadingDate: date
1149~
    # lastMeterReadingDate: date
1150~
    meterReadingExportPeriods: dict[str, object]
1151~
    advancedPaymentAmount: float
1152~
    hasCO2Compensation: bool
1153~
    hasInviteLink: bool
1154~
    status: str
1155~
    UserSettings: dict[str, object]
1156~
    PushNotificationPriceAlerts: list[object]
1157~
    # propositionType: str
1158~
    websiteUrl: str
1159~
    customerSupportEmail: str
1160~
    Signup: Signup
1161~
    treesCount: Optional[int] = 0
1162~
    friendsCount: Optional[int] = 0
1163~
    smartCharging: Optional[SmartCharging] = None
1164~
    smartTrading: Optional[SmartTrading] = None
1165~
    externalDetails: Optional[dict] = None
1166~
    deliveryEndDate: Optional[date] = None
1167~

1168~
    @staticmethod
1169~
    def from_dict(data: dict[str, object]) -> Optional["User"]:
1170~
        """Parse the response from the me query."""
1171~
        _LOGGER.debug("User %s", data)
1172~

1173~
        if errors := data.get("errors"):
1174~
            raise RequestException(errors[0]["message"])
1175~

1176~
        payload = data.get("data", {}).get("me")
1177~
        if payload is None:
1178~
            raise RequestException("Unexpected response")
1179~

1180~
        _LOGGER.debug("deliverySites %s", payload.get("deliverySites"))
1181~

1182~
        last_login_str = payload.get("lastLogin")
1183~
        last_login = None
1184~
        if last_login_str:
1185~
            try:
1186~
                last_login = datetime.fromisoformat(last_login_str)
1187~
            except ValueError:
1188~
                _LOGGER.warning("Invalid lastLogin format: %s", last_login_str)
1189~

1190~
        return User(
1191~
            id=payload.get("id"),
1192~
            InviteLinkUser=payload.get("InviteLinkUser"),
1193~
            Signup=payload.get("Signup"),
1194~
            Organization=payload.get("Organization"),
1195~
            PaymentAuthorizations=payload.get("PaymentAuthorizations"),
1196~
            activePaymentAuthorization=payload.get(
1197~
                "activePaymentAuthorization"),
1198~
            countryCode=payload.get("countryCode"),
1199~
            # segments=first_site.get("segments", []),
1200~
            # lastLogin=datetime.fromisoformat(payload.get("lastLogin")),
1201~
            lastLogin=last_login,
1202~
            createdAt=datetime.fromisoformat(payload.get("createdAt")),
1203~
            updatedAt=datetime.fromisoformat(payload.get("updatedAt")),
1204~
            email=payload.get("email"),
1205~
            reference=payload.get("reference"),
1206~
            connectionsStatus=payload.get("connectionsStatus"),
1207~
            # firstMeterReadingDate=payload.get("deliverySites")[
1208~
            #     0].get("firstMeterReadingDate"),
1209~
            # lastMeterReadingDate=payload.get("deliverySites")[
1210~
            #     0].get("lastMeterReadingDate"),
1211~
            # deliveryStartDate=first_site.get("deliveryStartDate"),
1212~
            # deliveryEndDate=first_site.get("deliveryEndDate"),
1213~
            # firstMeterReadingDate=first_site.get("firstMeterReadingDate"),
1214~
            # lastMeterReadingDate=first_site.get("lastMeterReadingDate"),
1215~
            meterReadingExportPeriods=payload.get(
1216~
                "meterReadingExportPeriods", {}),
1217~
            advancedPaymentAmount=payload.get("advancedPaymentAmount"),
1218~
            hasInviteLink=payload.get("hasInviteLink", False),
1219~
            hasCO2Compensation=payload.get("hasCO2Compensation", False),
1220~
            treesCount=payload.get("treesCount", 0),
1221~
            friendsCount=payload.get("friendsCount", 0),
1222~
            status=payload.get("status"),
1223~
            websiteUrl=payload.get("websiteUrl"),
1224~
            customerSupportEmail=payload.get("customerSupportEmail"),
1225~
            UserSettings=payload.get("UserSettings", {}),
1226~
            PushNotificationPriceAlerts=payload.get(
1227~
                "PushNotificationPriceAlerts", []),
1228~
            # propositionType=payload.get("deliverySites")[
1229~
            #     0].get("propositionType"),
1230~
            # smartCharging=payload.get("deliverySites")[
1231~
            #     0].get("smartCharging"),
1232~
            # propositionType=first_site.get("propositionType"),
1233~
            smartCharging=payload.get("smartCharging", {}),
1234~
            smartTrading=payload.get("smartTrading", {}),
1235~
            connections=payload.get("connections", {}),
1236~
            externalDetails=ExternalDetails.from_dict(
1237~
                payload.get("externalDetails", {}))
1238~
        )
1239~

1240~
    # verwijder dit is verplaatst naar de deliverysite class
1241~
    @property
1242~
    def format_delivery_site_as_dict(self):
1243~
        sites_as_dict = []
1244~
        for site in self.deliverySites:
1245~
            address = site.get('address', {})
1246~
            sites_as_dict.append(
1247~
                f"{address.get('street')} {address.get('houseNumber')} {address.get('houseNumberAddition', '') if address.get('houseNumberAddition') else ''} {address.get('zipCode')} {address.get('city')}")
1248~
        return sites_as_dict
1249~

1250~
    @property
1251~
    def delivery_site_as_list(self):
1252~
        sites = []
1253~
        for index, site in enumerate(self.deliverySites, start=1):
1254~
            address = site.get('address', {})
1255~
            site_name = f"Delivery site {index}"
1256~
            house_number_addition = f"{address.get('houseNumberAddition')}" if address.get(
1257~
                'houseNumberAddition') else ""
1258~
            site_info = {
1259~
                site_name: f"{address.get('street')} {address.get('houseNumber')} {house_number_addition if house_number_addition else ''} {address.get('zipCode')} {address.get('city')}"
1260~
            }
1261~
            sites.append(site_info)
1262~
        return sites
1263~

1264~
    @property
1265~
    def delivery_site_as_dict(self):
1266~
        site_dict = {}
1267~
        for index, site in enumerate(self.deliverySites, start=1):
1268~
            address = site.get('address', {})
1269~
            site_name = f"Delivery site {index}"
1270~
            site_info = {
1271~
                "street": address.get('street'),
1272~
                "house_number": address.get('houseNumber'),
1273~
                "zip_code": address.get('zipCode'),
1274~
                "city": address.get('city')
1275~
            }
1276~
            if address.get('houseNumberAddition'):
1277~
                site_info["house_number_addition"] = address.get(
1278~
                    'houseNumberAddition', '')
1279~
            site_dict[site_name] = site_info
1280~
        return site_dict
1281~

1282~
    @property
1283~
    def delivery_sites(self) -> dict[str, dict]:
1284~
        site_dict = {}
1285~
        for index, site in enumerate(self.deliverySites, start=1):
1286~
            address = site.get('address', {})
1287~
            site_name = f"Delivery site {index}"
1288~
            site_info = {
1289~
                f"{address.get('street')} {address.get('houseNumber')} {address.get('houseNumberAddition', '') if address.get('houseNumberAddition') else ''} {address.get('zipCode')} {address.get('city')}"
1290~
            }
1291~
            site_dict[site_name] = site_info
1292~
        return site_dict
1293~

1294~

1295~
@dataclass
1296~
class MonthInsights:
1297~
    """Month summary data, including the actual and expected costs for this month."""
1298~

1299~
    actualCostsUntilLastMeterReading: float
1300~
    expectedCostsUntilLastMeterReading: float
1301~
    expectedCosts: float
1302~
    lastMeterReadingDate: datetime
1303~

1304~
    @staticmethod
1305~
    def from_dict(data: dict[str, str]) -> Union['MonthInsights', None]:
1306~
        """Parse the response from the monthSummary query."""
1307~
        _LOGGER.debug("MonthInsights %s", data)
1308~

1309~
        if data is None:
1310~
            return None
1311~

1312~
        if errors := data.get("errors"):
1313~
            raise RequestException(errors[0]["message"])
1314~

1315~
        payload = data.get("data", {}).get("monthInsights")
1316~
        if payload is None:
1317~
            raise RequestException("Unexpected response")
1318~

1319~
        return MonthInsights(
1320~
            actualCostsUntilLastMeterReading=payload.get(
1321~
                "actualCostsUntilLastMeterReading"),
1322~
            expectedCostsUntilLastMeterReading=payload.get(
1323~
                "expectedCostsUntilLastMeterReading"),
1324~
            expectedCosts=payload.get("expectedCosts"),
1325~
            lastMeterReadingDate=payload.get("lastMeterReadingDate"),
1326~
        )
1327~

1328~

1329~
@dataclass
1330~
class MonthSummary:
1331~
    """Month summary data, including the actual and expected costs for this month."""
1332~

1333~
    _id: str
1334~
    actualCostsUntilLastMeterReadingDate: float
1335~
    expectedCostsUntilLastMeterReadingDate: float
1336~
    expectedCosts: float
1337~
    expectedCostsPerDay: float
1338~
    lastMeterReadingDate: datetime
1339~
    CostsPerDayTillNow: float
1340~
    meterReadingDayCompleteness: int
1341~
    gasExcluded: bool
1342~
    typename: str
1343~

1344~
    @staticmethod
1345~
    def from_dict(data: dict[str, str]) -> Optional['MonthSummary']:
1346~
        """Parse the response from the monthSummary query."""
1347~
        _LOGGER.debug("MonthSummary %s", data)
1348~

1349~
        if data is None:
1350~
            return None
1351~

1352~
        if errors := data.get("errors"):
1353~
            raise RequestException(errors[0]["message"])
1354~

1355~
        payload = data.get("data", {}).get("monthSummary")
1356~
        if payload is None:
1357~
            raise RequestException("Unexpected response")
1358~

1359~
        expected_costs_per_day = MonthSummary.calculate_expected_costs_per_day(
1360~
            payload.get("expectedCosts"), payload.get("lastMeterReadingDate"))
1361~
        costs_per_day_till_now = MonthSummary.calculate_costs_per_day_till_now(payload.get(
1362~
            "actualCostsUntilLastMeterReadingDate"), payload.get("lastMeterReadingDate"))
1363~

1364~
        return MonthSummary(
1365~
            _id=payload.get("_id"),
1366~
            actualCostsUntilLastMeterReadingDate=payload.get(
1367~
                "actualCostsUntilLastMeterReadingDate"),
1368~
            expectedCostsUntilLastMeterReadingDate=payload.get(
1369~
                "expectedCostsUntilLastMeterReadingDate"),
1370~
            expectedCosts=payload.get("expectedCosts"),
1371~
            expectedCostsPerDay=expected_costs_per_day,
1372~
            CostsPerDayTillNow=costs_per_day_till_now,
1373~
            lastMeterReadingDate=payload.get("lastMeterReadingDate"),
1374~
            meterReadingDayCompleteness=payload.get(
1375~
                "meterReadingDayCompleteness"),
1376~
            gasExcluded=payload.get("lastMeterReadingDate"),
1377~
            typename=payload.get("__typename")
1378~
        )
1379~

1380~
    @staticmethod
1381~
    def calculate_expected_costs_per_day(expected_costs: float, lastMeterReadingDate: datetime) -> float:
1382~
        """Calculate the expected costs per day."""
1383~
        last_meter_reading_date = datetime.strptime(
1384~
            lastMeterReadingDate, '%Y-%m-%d')
1385~
        last_meter_reading_month = last_meter_reading_date.month
1386~
        days_in_month = (last_meter_reading_date.replace(month=last_meter_reading_month % 12 + 1, day=1) -
1387~
                         datetime(year=last_meter_reading_date.year, month=last_meter_reading_month, day=1)).days
1388~
        return expected_costs / days_in_month
1389~

1390~
    @staticmethod
1391~
    def calculate_costs_per_day_till_now(costs_till_now: float, lastMeterReadingDate: datetime) -> float:
1392~
        """Calculate the costs per day this month till now."""
1393~
        last_meter_reading_date = datetime.strptime(
1394~
            lastMeterReadingDate, '%Y-%m-%d')
1395~
        if last_meter_reading_date.day > 1:  # skip day one
1396~
            days_till_last_reading = last_meter_reading_date.day  # always one day behind
1397~
            # return the cost divided by the days
1398~
            return costs_till_now / days_till_last_reading
1399~
        return costs_till_now  # return the cost on the fist day
1400~

1401~
    @property
1402~
    def differenceUntilLastMeterReadingDate(self) -> float:
1403~
        """The difference between the expected costs and the actual costs."""
1404~
        return self.actualCostsUntilLastMeterReadingDate - self.expectedCostsUntilLastMeterReadingDate
1405~

1406~
    @property
1407~
    def differenceUntilLastMeterReadingDateAvg(self) -> float:
1408~
        """The difference between the expected costs and the actual costs per day."""
1409~
        last_meter_reading_date = datetime.strptime(
1410~
            self.lastMeterReadingDate, '%Y-%m-%d')
1411~
        if last_meter_reading_date.day > 1:  # skip day one
1412~
            days_till_last_reading = last_meter_reading_date.day
1413~
            return self.differenceUntilLastMeterReadingDate / days_till_last_reading
1414~
        return self.differenceUntilLastMeterReadingDate
1415~

1416~

1417~
@dataclass
1418~
class ChargeSettings:
1419~
    """Represents the charge settings for an enode charger."""
1420~
    calculated_deadline: datetime
1421~
    capacity: float
1422~
    deadline: Optional[datetime]
1423~
    hour_friday: int
1424~
    hour_monday: int
1425~
    hour_saturday: int
1426~
    hour_sunday: int
1427~
    hour_thursday: int
1428~
    hour_tuesday: int
1429~
    hour_wednesday: int
1430~
    id: str
1431~
    initial_charge: float
1432~
    initial_charge_timestamp: datetime
1433~
    is_smart_charging_enabled: bool
1434~
    is_solar_charging_enabled: bool
1435~
    max_charge_limit: float
1436~
    min_charge_limit: float
1437~

1438~

1439~
@dataclass
1440~
class ChargeState:
1441~
    """Represents the charge state for an enode charger."""
1442~
    battery_capacity: Optional[float]
1443~
    battery_level: Optional[float]
1444~
    charge_limit: Optional[float]
1445~
    charge_rate: Optional[float]
1446~
    charge_time_remaining: Optional[float]
1447~
    is_charging: bool
1448~
    is_fully_charged: Optional[bool]
1449~
    is_plugged_in: bool
1450~
    last_updated: datetime
1451~
    power_delivery_state: str
1452~
    range: Optional[float]
1453~

1454~

1455~
@dataclass
1456~
class Intervention:
1457~
    """Represents an intervention for an enode charger."""
1458~
    description: str
1459~
    title: str
1460~

1461~

1462~
@dataclass
1463~
class EnodeCharger:
1464~
    """Represents a single enode charger with relevant information."""
1465~
    can_smart_charge: bool
1466~
    charge_settings: ChargeSettings
1467~
    charge_state: ChargeState
1468~
    id: str
1469~
    information: dict
1470~
    interventions: list[Intervention]
1471~
    is_reachable: bool
1472~
    last_seen: datetime
1473~

1474~
    @classmethod
1475~
    def from_dict(cls, data: dict) -> 'EnodeCharger':
1476~
        """Create an instance of EnodeCharger from a dictionary."""
1477~
        charge_settings_data = data['chargeSettings']
1478~
        charge_state_data = data['chargeState']
1479~
        interventions_data = data['interventions']
1480~
        
1481~
        charge_settings = ChargeSettings(
1482~
            calculated_deadline=datetime.fromisoformat(charge_settings_data['calculatedDeadline']),
1483~
            capacity=charge_settings_data['capacity'],
1484~
            deadline=datetime.fromisoformat(charge_settings_data['deadline']) if charge_settings_data['deadline'] else None,
1485~
            hour_friday=charge_settings_data['hourFriday'],
1486~
            hour_monday=charge_settings_data['hourMonday'],
1487~
            hour_saturday=charge_settings_data['hourSaturday'],
1488~
            hour_sunday=charge_settings_data['hourSunday'],
1489~
            hour_thursday=charge_settings_data['hourThursday'],
1490~
            hour_tuesday=charge_settings_data['hourTuesday'],
1491~
            hour_wednesday=charge_settings_data['hourWednesday'],
1492~
            id=charge_settings_data['id'],
1493~
            initial_charge=charge_settings_data['initialCharge'],
1494~
            initial_charge_timestamp=datetime.fromisoformat(charge_settings_data['initialChargeTimestamp']),
1495~
            is_smart_charging_enabled=charge_settings_data['isSmartChargingEnabled'],
1496~
            is_solar_charging_enabled=charge_settings_data['isSolarChargingEnabled'],
1497~
            max_charge_limit=charge_settings_data['maxChargeLimit'],
1498~
            min_charge_limit=charge_settings_data['minChargeLimit']
1499~
        )
1500~

1501~
        charge_state = ChargeState(
1502~
            battery_capacity=charge_state_data['batteryCapacity'],
1503~
            battery_level=charge_state_data['batteryLevel'],
1504~
            charge_limit=charge_state_data['chargeLimit'],
1505~
            charge_rate=charge_state_data['chargeRate'],
1506~
            charge_time_remaining=charge_state_data['chargeTimeRemaining'],
1507~
            is_charging=charge_state_data['isCharging'],
1508~
            is_fully_charged=charge_state_data['isFullyCharged'],
1509~
            is_plugged_in=charge_state_data['isPluggedIn'],
1510~
            last_updated=datetime.fromisoformat(charge_state_data['lastUpdated']),
1511~
            power_delivery_state=charge_state_data['powerDeliveryState'],
1512~
            range=charge_state_data['range']
1513~
        )
1514~

1515~
        interventions = [Intervention(description=intervention['description'], title=intervention['title'])
1516~
                         for intervention in interventions_data]
1517~

1518~
        return cls(
1519~
            can_smart_charge=data['canSmartCharge'],
1520~
            charge_settings=charge_settings,
1521~
            charge_state=charge_state,
1522~
            id=data['id'],
1523~
            information=data['information'],
1524~
            interventions=interventions,
1525~
            is_reachable=data['isReachable'],
1526~
            last_seen=datetime.fromisoformat(data['lastSeen'])
1527~
        )
1528~

1529~

1530~
@dataclass
1531~
class EnodeChargers:
1532~
    """Represents a collection of enode chargers."""
1533~
    chargers: list[EnodeCharger]
1534~

1535~
    @classmethod
1536~
    def from_dict(cls, data: list[dict]) -> 'EnodeChargers':
1537~
        """Create an instance of EnodeChargers from a list of dictionaries."""
1538~
        chargers = [EnodeCharger.from_dict(item) for item in data]
1539~
        return cls(chargers=chargers)
1540~

1541~
    def old_as_dict(self) -> dict[str, EnodeCharger]:
1542~
        """Convert the charger list to a dictionary keyed by charger ID."""
1543~
        return {charger.id: charger for charger in self.chargers}
1544~

1545~
    def as_dict(self) -> dict[str, EnodeCharger]:
1546~
        """Return only chargers with smart charging enabled as a dict keyed by charger ID."""
1547~
        return {
1548~
            charger.id: charger
1549~
            for charger in self.chargers
1550~
            if charger.charge_settings.is_smart_charging_enabled
1551~
        }
1552~

1553~
@dataclass
1554~
class Price:
1555~
    """Price data for one hour."""
1556~

1557~
    date_from: datetime
1558~
    date_till: datetime
1559~
    price_data: list['Price']
1560~
    energy_type: Optional[str] = None
1561~
    market_price: float = 0.0
1562~
    market_price_tax: float = 0.0
1563~
    sourcing_markup_price: float = 0.0
1564~
    energy_tax_price: float = 0.0
1565~
    total: float = 0.0
1566~
    per_unit: Optional[str] = None
1567~
    unit: Optional[str] = None      
1568~
    tax_rate: float = 0.0
1569~
    tax: float = 0.0
1570~
    start_time: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
1571~
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
1572~
    for_now: bool = False
1573~
    for_today: bool = False
1574~
    for_tomorrow: bool = False
1575~
    for_upcoming: bool = False
1576~
    market_price_including_tax: float = 0.0
1577~
    market_price_including_tax_and_markup: float = 0.0
1578~

1579~
    def __post_init__(self):
1580~
        """Initialize energy_type if provided in data.
1581~
        This method sets the energy tax price based on the energy type.
1582~
        This tax is for The Netherlands and may change yearly.
1583~
        The values are based on the energy tax for electricity and gas in 2025.
1584~
        0,101541,21=0,12286 per kWh (<10.000 kWh)
1585~
        Iedere aansluiting krijgt in 2025 een vermindering van  635,19 (inclusief btw) (tot ~4.700 kWh) via de belastingvermindering/regeling basisbehoefte
1586~

1587~
        Onderdeel	Tarief 2025
1588~
        Energiebelasting stroom (<10.000 kWh)	0,10154/kWh excl. btw  0,12286/kWh incl. btw
1589~
        Energiebelasting stroom (>10.000 kWh)	0,06937/kWh excl. btw  0,08400/kWh incl. btw
1590~
        Vermindering energiebelasting	635,19 per jaar (incl. btw)
1591~
        """
1592~
        if self.energy_type:
1593~
            if self.energy_type == "electricity":
1594~
                # self.energy_tax_price = 0.15239 # electricity tax 2023
1595~
                # self.energy_tax_price = 0.13165  # electricity tax 2024
1596~
                self.energy_tax_price = 0.1228634  # electricity tax 2025 incl. BTW
1597~
            if self.energy_type == "gas":
1598~
                # self.energy_tax_price = 0.5927 # gas tax 2023
1599~
                # self.energy_tax_price = 0.70544  # gas tax 2024
1600~
                self.energy_tax_price = 0.6995736  # gas tax 2025
1601~
        # not in use anymore, get energy_tax_price from API response
1602~

1603~
    def __init__(self, data: dict, energy_type: Optional[str] = None) -> None:
1604~
        """Parse the response from the prices query."""
1605~
        self.energy_type = energy_type
1606~
        # self.energy_type = data.get("energy_type", None)
1607~

1608~
        date_from_str = data.get('from', '')
1609~
        date_till_str = data.get('till', '')
1610~
        self.date_from = None
1611~
        self.date_till = None
1612~

1613~
        if date_from_str:
1614~
            try:
1615~
                # Step 1: Replace 'Z' with '+00:00' to indicate UTC
1616~
                date_str = date_from_str.replace('Z', '+00:00')
1617~
                
1618~
                # Step 2: Parse the date string to a datetime object
1619~
                dt = datetime.fromisoformat(date_str)
1620~
                
1621~
                # Step 3: Convert the datetime object to ISO 8601 format
1622~
                iso_format_date = dt.isoformat()
1623~
                self.date_from = datetime.fromisoformat(iso_format_date)  # Regular datetime
1624~
            except ValueError:
1625~
                logging.warning("Invalid ISO date format: '%s'", date_from_str)
1626~

1627~
        if date_till_str:
1628~
            try:
1629~
                # Step 1: Replace 'Z' with '+00:00' to indicate UTC
1630~
                date_str = date_till_str.replace('Z', '+00:00')
1631~
                
1632~
                # Step 2: Parse the date string to a datetime object
1633~
                dt = datetime.fromisoformat(date_str)
1634~
                
1635~
                # Step 3: Convert the datetime object to ISO 8601 format
1636~
                iso_format_date = dt.isoformat()
1637~
                self.date_till = datetime.fromisoformat(iso_format_date)  # Regular datetime
1638~
            except ValueError:
1639~
                logging.warning("Invalid ISO date format: '%s'", date_till_str)
1640~

1641~
        """ The market price of the product or service. """
1642~
        self.market_price = data["marketPrice"]
1643~
        """ The amount of tax added to the market price. """
1644~
        self.market_price_tax = data["marketPriceTax"]
1645~
        """ The amount of sourcing markup added to the market price. """
1646~
        self.sourcing_markup_price = data["sourcingMarkupPrice"]
1647~
        self.energy_tax_price = data["energyTaxPrice"]
1648~
        self.market_price_including_tax = self.market_price + self.market_price_tax
1649~

1650~
        # Tax added to the market price including tax and markup
1651~
        self.market_price_including_tax_and_markup = (
1652~
            self.market_price + self.market_price_tax + self.sourcing_markup_price
1653~
        )
1654~

1655~
        self.per_unit = data['perUnit']
1656~

1657~
        # Check if the "energy_type" key is present in the data dictionary
1658~
        # print("DATA:", self)
1659~
        # print("TESTDATA:", data)
1660~

1661~
    def per_unit(self) -> str:
1662~
        """Return the unit of the price."""
1663~
        if self.per_unit:
1664~
            return self.per_unit
1665~
        return None
1666~

1667~
    def __str__(self) -> str:
1668~
        """Return a string representation of this price entry."""
1669~
        return "%s -> %s: %.4f %s" % (
1670~
            self.date_from.isoformat() if self.date_from else "N/A",
1671~
            self.date_till.isoformat() if self.date_till else "N/A",
1672~
            self.total,
1673~
            self.per_unit or ""
1674~
        )
1675~

1676~
    @property
1677~
    def ET(self, data) -> str: # not in use anymore
1678~
        """Returns energy type 'electricity' or 'gas'."""
1679~
        if "energy_type" in data:
1680~
            self.energy_type = data["energy_type"]
1681~
            if self.energy_type == "electricity":
1682~
                # self.energy_tax_price = 0.15239 # electricity tax 2023
1683~
                # self.energy_tax_price = 0.13165  # electricity tax 2024
1684~
                self.energy_tax_price = 0.1228634  # electricity tax 2025
1685~
            if self.energy_type == "gas":
1686~
                # self.energy_tax_price = 0.5927 # gas tax 2023
1687~
                # self.energy_tax_price = 0.70544  # gas tax 2024
1688~
                self.energy_tax_price = 0.6995736  # gas tax 2025
1689~
            return data["energy_type"]
1690~
        else:
1691~
            return None
1692~

1693~
    @property
1694~
    def for_now(self) -> bool:
1695~
        """Whether this price entry is for the current hour."""
1696~
        return self.date_from <= datetime.now(timezone.utc) < self.date_till
1697~

1698~
    @property
1699~
    def for_future(self) -> bool:
1700~
        """Whether this price entry is for and hour after the current one."""
1701~
        return self.date_from.hour > datetime.now(timezone.utc).hour
1702~

1703~
    @property
1704~
    def for_today(self) -> bool:
1705~
        """Whether this price entry is for the current day."""
1706~
        now = datetime.now(timezone.utc).astimezone(
1707~
        )  # Convert to local timezone
1708~
        day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
1709~
        day_end = day_start + timedelta(days=1)
1710~
        return self.date_from >= day_start and self.date_till <= day_end
1711~

1712~
    @property
1713~
    def for_tomorrow(self) -> bool:
1714~
        """Whether this price entry is for tomorrow."""
1715~
        now = datetime.now(timezone.utc).astimezone(
1716~
        )  # Convert to local timezone
1717~
        tomorrow = now + timedelta(days=1)
1718~
        tomorrow_start = tomorrow.replace(
1719~
            hour=0, minute=0, second=0, microsecond=0)
1720~
        tomorrow_end = tomorrow_start + timedelta(days=1)
1721~
        return tomorrow_start <= self.date_from < tomorrow_end
1722~

1723~
    @property
1724~
    def for_upcoming(self) -> bool:
1725~
        """ Whether this price entry is for a hour after the current one. """
1726~
        now = datetime.now(timezone.utc).astimezone()
1727~
        return self.date_from > now
1728~

1729~
    @property
1730~
    def for_previous_hour(self) -> bool:
1731~
        """ Whether this price entry is for the previous hour. """
1732~
        now = datetime.now(timezone.utc).astimezone(
1733~
        )  # Convert to local timezone
1734~
        previous_hour_start = now.replace(
1735~
            microsecond=0, second=0, minute=0) - timedelta(hours=1)
1736~
        return self.date_from == previous_hour_start
1737~

1738~
    @property
1739~
    def for_next_hour(self) -> bool:
1740~
        """ Whether this price entry is for the next hour. """
1741~
        now = datetime.now(timezone.utc).astimezone(
1742~
        )  # Convert to local timezone
1743~
        next_hour_start = now.replace(
1744~
            microsecond=0, second=0, minute=0) + timedelta(hours=1)
1745~
        next_hour_end = next_hour_start + timedelta(hours=1)
1746~
        return next_hour_start <= self.date_from < next_hour_end
1747~

1748~
    @property
1749~
    def previous_hour(self):
1750~
        """ Price that was the previous hour applicable. """
1751~
        return next((hour for hour in self.price_data if hour.for_previous_hour), None)
1752~

1753~
    @property
1754~
    def next_hour(self):
1755~
        """ Price that is-the next hour applicable. """
1756~
        return next((hour for hour in self.price_data if hour.for_next_hour), None)
1757~

1758~
    # Calculate the market price with tax by adding marketPrice and marketPriceTax
1759~
    @property
1760~
    def market_price_with_tax(self) -> float:
1761~
        """The market price including tax."""
1762~
        return self.market_price + self.market_price_tax
1763~

1764~
    # Calculate the market price with tax and sourcing markup by adding marketPrice, marketPriceTax and sourcing_markup_price
1765~
    @property
1766~
    def market_price_with_tax_and_markup(self) -> float:
1767~
        """The market price including tax."""
1768~
        return self.market_price + self.market_price_tax + self.sourcing_markup_price
1769~

1770~
    @property
1771~
    def total(self) -> float:
1772~
        """The total price for this hour."""
1773~
        if not hasattr(self, '_total'):
1774~
            self._total = (
1775~
                self.market_price +
1776~
                self.market_price_tax +
1777~
                self.sourcing_markup_price +
1778~
                self.energy_tax_price
1779~
            )
1780~
        return self._total
1781~

1782~
    def calculate_stats1(self, prices: list['Price']) -> dict[str, float]:
1783~
        if not prices:
1784~
            return {}
1785~

1786~
        price_values = [price.market_price for price in prices]
1787~
        total_prices = [price.total for price in prices]
1788~
        return {
1789~
            "min": min(price_values),
1790~
            "max": max(price_values),
1791~
            "avg": mean(total_prices),
1792~
        }
1793~

1794~
    @staticmethod
1795~
    def calculate_stats2(prices: list[float]) -> dict[str, float]:
1796~
        if not prices:
1797~
            return {}
1798~

1799~
        # Calculate the minimum price
1800~
        min_price = min(prices)
1801~

1802~
        # Calculate the maximum price
1803~
        max_price = max(prices)
1804~

1805~
        # Calculate the average price
1806~
        avg_price = mean(prices)
1807~

1808~
        # Calculate the total price
1809~
        total_price = sum(prices)
1810~

1811~
        # Calculate the standard deviation
1812~
        n = len(prices)
1813~
        std_dev = (sum((x - avg_price) ** 2 for x in prices) / n) ** 0.5
1814~

1815~
        # Create a dictionary to store the calculated statistics
1816~
        stats = {
1817~
            'min_price': min_price,
1818~
            'max_price': max_price,
1819~
            'avg_price': avg_price,
1820~
            'total_price': total_price,
1821~
            'std_dev': std_dev
1822~
        }
1823~

1824~
        return stats
1825~

1826~
    @staticmethod
1827~
    def calculate_stats3(data: dict) -> dict[str, dict[str, float]]:
1828~
        if not data:
1829~
            return {}
1830~
        electricity_prices = [entry['marketPrice']
1831~
                              for entry in data['marketPricesElectricity']]
1832~
        gas_prices = [entry['marketPrice']
1833~
                      for entry in data['marketPricesGas']]
1834~

1835~
        electricity_mean = mean(electricity_prices)
1836~
        gas_mean = mean(gas_prices)
1837~

1838~
        electricity_min = min(electricity_prices)
1839~
        gas_min = min(gas_prices)
1840~

1841~
        electricity_max = max(electricity_prices)
1842~
        gas_max = max(gas_prices)
1843~

1844~
        electricity_std_dev = (sum(
1845~
            (x - electricity_mean) ** 2 for x in electricity_prices) / len(electricity_prices)) ** 0.5
1846~
        gas_std_dev = (
1847~
            sum((x - gas_mean) ** 2 for x in gas_prices) / len(gas_prices)) ** 0.5
1848~

1849~
        return {
1850~
            'electricity': {
1851~
                'mean': electricity_mean,
1852~
                'min': electricity_min,
1853~
                'max': electricity_max,
1854~
                'std_dev': electricity_std_dev
1855~
            },
1856~
            'gas': {
1857~
                'mean': gas_mean,
1858~
                'min': gas_min,
1859~
                'max': gas_max,
1860~
                'std_dev': gas_std_dev
1861~
            }
1862~
        }
1863~

1864~

1865~
@dataclass
1866~
class PriceDataAvg:
1867~
    """Dataclass representing average price data for a time period."""
1868~
    values: list[Price]
1869~
    total: float
1870~
    market_price_with_tax_and_markup: float
1871~
    market_markup_price: float
1872~
    market_price_with_tax: float
1873~
    market_price_tax: float
1874~
    market_price: float
1875~

1876~

1877~
class PriceData:
1878~
    """Price data for a period of time."""
1879~
    price_data: list[Price] = []
1880~
    energy_type: Optional[str] = None
1881~
    current_hour: Price = None
1882~
    previous_hour: Price = None
1883~
    next_hour: Price = None
1884~
    upcoming_min: Price = None
1885~
    upcoming_max: Price = None
1886~
    upcoming_avg: PriceDataAvg = None
1887~
    upcoming_prices: list[Price] = None
1888~
    elec_previoushour: float = None
1889~
    elec_nexthour: float = None
1890~
    gas_unit: str = None
1891~
    elec_unit: str = None
1892~

1893~
    """" 
1894~
    PriceDataAvg = namedtuple('PriceDataAvg', [
1895~
        'values', 'total', 'market_price_with_tax_and_markup',
1896~
        'market_markup_price', 'market_price_with_tax',
1897~
        'market_price_tax', 'market_price'
1898~
    ])
1899~
    """
1900~

1901~
    def __init__(self, prices: Optional[list['Price']] = None, energy_type: Optional[str] = None):
1902~
        self.price_data = [Price({**price, "energy_type": energy_type})
1903~
                           for price in prices] if prices else []
1904~
        self.energy_type = energy_type
1905~

1906~
    def __add__(self, other: 'PriceData') -> 'PriceData':
1907~
        """Combine two PriceData objects."""
1908~
        pd = PriceData()
1909~
        pd.price_data = self.price_data + other.price_data
1910~
        return pd
1911~

1912~
    def __str__(self):
1913~
        """Return a string representation of this price data."""
1914~
        return str([str(price) for price in self.price_data])
1915~

1916~
    def filter_prices(self, start_date: datetime, end_date: datetime) -> list[Price]:
1917~
        """Filter prices based on start and end dates."""
1918~
        return [price for price in self.price_data if start_date <= price.date_from <= end_date]
1919~

1920~
    @property
1921~
    def all(self) -> list[Price]:
1922~
        """All prices."""
1923~
        return self.price_data
1924~

1925~
    @property
1926~
    def today(self) -> list[Price]:
1927~
        """Prices for today."""
1928~
        return [hour for hour in self.price_data if hour.for_today]
1929~

1930~
    @property
1931~
    def tomorrow(self) -> list[Price]:
1932~
        """Prices for tomorrow."""
1933~
        return [hour for hour in self.price_data if hour.for_tomorrow]
1934~

1935~
    @property
1936~
    def previous_hour(self) -> Optional['Price']:
1937~
        """ Price that was the previous hour applicable. """
1938~
        return next((hour for hour in self.price_data if hour.for_previous_hour), None)
1939~

1940~
    @property
1941~
    def current_hour(self) -> Optional['Price']:
1942~
        """ Price that's currently applicable. """
1943~
        matching_hours = [hour for hour in self.price_data if hour.for_now]
1944~
        if matching_hours:
1945~
            return matching_hours[0]
1946~
        else:  # only occurs when hour.for_now is not in range of price_data
1947~
            return None
1948~

1949~
    @property
1950~
    def next_hour(self) -> Optional['Price']:
1951~
        """ Price that's next hour applicable. """
1952~
        return next((hour for hour in self.price_data if hour.for_next_hour), None)
1953~

1954~
    @property
1955~
    def today_tax_markup_avg(self) -> float:
1956~
        """ Average market price including tax and markup for today. """
1957~
        today_market_tax_markup = [
1958~
            hour.market_price_with_tax_and_markup for hour in self.today_prices]
1959~
        return mean(today_market_tax_markup)
1960~

1961~
    @property
1962~
    def today_min(self) -> Optional[Price]:
1963~
        """Price with the lowest total for today."""
1964~
        if not self.today == []:
1965~
            return min([hour for hour in self.today], key=lambda hour: hour.total)
1966~

1967~
    @property
1968~
    def today_max(self) -> Optional[Price]:
1969~
        """Price with the highest total for today."""
1970~
        if not self.today == []:
1971~
            return max([hour for hour in self.today], key=lambda hour: hour.total)
1972~

1973~
    @property
1974~
    def today_avg(self) -> float:
1975~
        """Average price for today."""
1976~
        if not self.today == []:
1977~
            return mean(hour.total for hour in self.today)
1978~

1979~
    @property  # todo
1980~
    def tomorrow_average_price(self) -> Optional[float]:
1981~
        """ Average total price for tomorrow. """
1982~
        tomorrow_prices = self.get_prices_for_time_period(TimePeriod.TOMORROW)
1983~

1984~
        if not tomorrow_prices:
1985~
            return None
1986~

1987~
        average_price = mean(price.total for price in tomorrow_prices)
1988~
        rounded_average_price = round(average_price, DEFAULT_ROUND)
1989~

1990~
        return rounded_average_price
1991~

1992~
    @property
1993~
    def tomorrow_average_price_including_tax(self) -> Optional[float]:
1994~
        """ Average total price including tax and markup for tomorrow. """
1995~
        tomorrow_prices = self.get_prices_for_time_period(TimePeriod.TOMORROW)
1996~

1997~
        if not tomorrow_prices:
1998~
            return None
1999~

2000~
        average_price = mean(
2001~
            price.market_price_including_tax for price in tomorrow_prices)
2002~
        rounded_average_price = round(average_price, DEFAULT_ROUND)
2003~

2004~
        return rounded_average_price
2005~

2006~
    @property
2007~
    def tomorrow_average_price_including_tax_and_markup(self) -> Optional[float]:
2008~
        """ Average total price including tax and markup for tomorrow. """
2009~
        tomorrow_prices = self.get_prices_for_time_period(TimePeriod.TOMORROW)
2010~

2011~
        if not tomorrow_prices:
2012~
            return None
2013~

2014~
        average_price = mean(
2015~
            price.market_price_including_tax_and_markup for price in tomorrow_prices)
2016~
        rounded_average_price = round(average_price, DEFAULT_ROUND)
2017~

2018~
        return rounded_average_price
2019~

2020~
    @property
2021~
    def tomorrow_average_market_price(self) -> Optional[float]:
2022~
        """ Average market price for tomorrow. """
2023~
        tomorrow_prices = self.get_prices_for_time_period(TimePeriod.TOMORROW)
2024~

2025~
        if not tomorrow_prices:
2026~
            return None
2027~

2028~
        average_price = mean(price.market_price for price in tomorrow_prices)
2029~
        rounded_average_price = round(average_price, DEFAULT_ROUND)
2030~

2031~
        return rounded_average_price
2032~

2033~
    @property
2034~
    def tomorrow_min(self) -> Optional[Price]:
2035~
        """Price with the lowest total for today."""
2036~
        if not self.tomorrow == []:
2037~
            return min([hour for hour in self.tomorrow], key=lambda hour: hour.total)
2038~

2039~
    @property
2040~
    def tomorrow_max(self) -> Optional[Price]:
2041~
        """Price with the highest total for today."""
2042~
        if not self.tomorrow == []:
2043~
            return max([hour for hour in self.tomorrow], key=lambda hour: hour.total)
2044~

2045~
    @property
2046~
    def all_min(self) -> Price:
2047~
        return min([hour for hour in self.price_data], key=lambda hour: hour.total)
2048~

2049~
    @property
2050~
    def all_max(self) -> Price:
2051~
        return max([hour for hour in self.price_data], key=lambda hour: hour.total)
2052~

2053~
    @property
2054~
    def upcoming(self) -> list[Price]:
2055~
        return [hour for hour in self.price_data if hour.for_upcoming]
2056~

2057~
    @property
2058~
    def all_attr(self):
2059~
        """ Electricity price data for the all hours """
2060~
        all_data = []
2061~
        total_price = 0
2062~
        for hour in self.price_data:
2063~
            all_data.append({
2064~
                'from': hour.date_from.isoformat(),
2065~
                'till': hour.date_till.isoformat(),
2066~
                'price': hour.total
2067~
            })
2068~
            total_price += hour.total
2069~
        return {
2070~
            'all_hours': all_data,
2071~
            'average': total_price / len(all_data) if len(all_data) > 0 else 0
2072~
        }
2073~

2074~
    @property
2075~
    def upcoming_attr(self):
2076~
        """ Electricity price data for the upcoming hours """
2077~
        upcoming_data = []
2078~
        total_price = 0
2079~
        for hour in self.price_data:
2080~
            if hour.for_upcoming:
2081~
                upcoming_data.append({
2082~
                    'from': hour.date_from.isoformat(),
2083~
                    'till': hour.date_till.isoformat(),
2084~
                    'price': hour.total
2085~
                })
2086~
                total_price += hour.total
2087~
        return {
2088~
            'upcoming': upcoming_data,
2089~
            'average': total_price / len(upcoming_data) if len(upcoming_data) > 0 else 0
2090~
        }
2091~

2092~
    @property
2093~
    def upcoming_min(self) -> Optional['Price']:
2094~
        return min([hour for hour in self.upcoming], key=lambda hour: hour.total)
2095~

2096~
    @property
2097~
    def upcoming_max(self) -> Optional['Price']:
2098~
        return max([hour for hour in self.upcoming], key=lambda hour: hour.total)
2099~

2100~
    @property
2101~
    def elec_previoushour(self):
2102~
        """Return the electricity price for the previous hour"""
2103~
        # Get the current time
2104~
        now = datetime.now()
2105~

2106~
        # Find the previous hour by subtracting one hour from the current time
2107~
        prev_hour = now - timedelta(hours=1)
2108~

2109~
        # Filter the list of prices to find the price for the previous hour
2110~
        prev_hour_prices = [
2111~
            price for price in self.price_data if price.date_from <= prev_hour <= price.date_till]
2112~

2113~
        # If there is a price for the previous hour, return it
2114~
        if prev_hour_prices:
2115~
            return prev_hour_prices[0]
2116~

2117~
        # If there is no price for the previous hour, return None
2118~
        return None
2119~

2120~
    @property
2121~
    def elec_nexthour(self):
2122~
        """Return the electricity price for the next hour"""
2123~
        # Get the current time
2124~
        now = datetime.now()
2125~

2126~
        # Find the next hour by adding one hour to the current time
2127~
        next_hour = now + timedelta(hours=1)
2128~

2129~
        # Filter the list of prices to find the price for the next hour
2130~
        next_hour_price = next(
2131~
            (price.total for price in self.price_data if price.date_from.time == next_hour), None)
2132~

2133~
        # Return the next hour price
2134~
        return next_hour_price
2135~

2136~
    @property
2137~
    def older_avg(self: list['PriceData']) -> float | None:
2138~
        """Calcutale the average price."""
2139~
        if not self:
2140~
            return mean(hour.total for hour in self.all)
2141~
        else:
2142~
            return None
2143~

2144~
    # Calculate the average price of a list of prices
2145~
    @property
2146~
    def avg(prices) -> float:
2147~
        # Calculate the average price of a list of prices
2148~
        return mean(prices)
2149~

2150~
    @property
2151~
    def today_tax_avg(self) -> float:
2152~
        """ Average market price including tax and markup for today. """
2153~
        today_market_prices_tax_markup = [
2154~
            hour.market_price_with_tax for hour in self.today_prices]
2155~
        return mean(today_market_prices_tax_markup)
2156~

2157~
    def average_price(self, start_date: datetime, end_date: datetime) -> float:
2158~
        """Get the average price for a period of time."""
2159~
        prices = self.filter_prices(start_date, end_date)
2160~
        if prices:
2161~
            return mean(price.total for price in prices)
2162~
        return 0.0
2163~

2164~
    def future_prices(self) -> list[Price]:
2165~
        """Prices for hours after the current one."""
2166~
        return [hour for hour in self.price_data if hour.for_upcoming]
2167~

2168~
    @property
2169~
    def upcoming_prices(self):
2170~
        """ Prices for hours after the current one. """
2171~
        return [hour for hour in self.price_data if hour.for_upcoming]
2172~

2173~
    @property
2174~
    def today_prices(self):
2175~
        """ Prices for today. """
2176~
        return [hour for hour in self.price_data if hour.for_today]
2177~

2178~
    @property
2179~
    def tomorrow_prices(self):
2180~
        """ Prices for tomorrow. """
2181~
        return [hour for hour in self.price_data if hour.for_tomorrow]
2182~

2183~
    def asdict(
2184~
        self,
2185~
        attr: str,
2186~
        upcoming_only: bool = False,
2187~
        today_only: bool = False,
2188~
        tomorrow_only: bool = False,
2189~
        timezone: str | None = None
2190~
    ) -> list[dict]:
2191~
        """
2192~
        Return a list of dictionaries suitable for use as entity attribute data.
2193~

2194~
        Args:
2195~
            attr (str): The attribute name (e.g., 'marketPrice') to extract from each price object.
2196~
            upcoming_only (bool): If True, include only upcoming prices.
2197~
            today_only (bool): If True, include only today's prices.
2198~
            tomorrow_only (bool): If True, include only tomorrow's prices.
2199~
            timezone (str | None): The timezone to localize the 'from' and 'till' datetimes. Defaults to UTC.
2200~

2201~
        Returns:
2202~
            list[dict]: A list of dicts with keys 'from', 'till', and the selected 'price'.
2203~
        """
2204~
        try:
2205~
            tz = pytz.timezone(timezone) if timezone else pytz.UTC
2206~

2207~
            # self.price_data is altijd een list
2208~
            if isinstance(self.price_data, list):
2209~
                if upcoming_only:
2210~
                    prices = self.upcoming_prices
2211~
                elif today_only:
2212~
                    prices = self.today_prices
2213~
                elif tomorrow_only:
2214~
                    prices = self.tomorrow_prices
2215~
                    if not prices:
2216~
                        return [{'message': 'No prices for tomorrow.'}]
2217~
                else:
2218~
                    prices = self.price_data
2219~
            else:
2220~
                if upcoming_only:
2221~
                    prices = [self]
2222~
                elif today_only:
2223~
                    prices = [p for p in self.price_data if p.for_today]
2224~
                elif tomorrow_only:
2225~
                    prices = [p for p in self.price_data if p.for_tomorrow]
2226~
                    if not prices:
2227~
                        return [{'message': 'No prices for tomorrow.'}]
2228~
                else:
2229~
                    prices = [self.price_data]
2230~

2231~
            # DEBUG: If the attribute is not found, return a list of dictionaries with the error message
2232~
            # return [{'type': type(self.price_data).__name__, 'price': price} for price in prices]
2233~

2234~
            return [
2235~
                {
2236~
                    'from': price.date_from.astimezone(tz),
2237~
                    'till': price.date_till.astimezone(tz),
2238~
                    'price': round(getattr(price, attr), 3),
2239~
                }
2240~
                for price in prices
2241~
            ]
2242~

2243~
        except AttributeError as err:
2244~
            _LOGGER.error("Price object has no attribute '%s'", err)
2245~
            return [{'error': f'Price object has no attribute: {err}'}]
2246~

2247~
        except Exception as exc:
2248~
            _LOGGER.exception(
2249~
                "Failed to convert price data to dict (attr=%s, upcoming_only=%s, today_only=%s, tomorrow_only=%s, timezone=%s): %s",
2250~
                attr, upcoming_only, today_only, tomorrow_only, timezone, exc
2251~
            )
2252~
            return [{'error': f'Failed to convert price data: {exc}'}]
2253~

2254~

2255~
    @staticmethod
2256~
    def asdict_to_local(prices_dict, timezone):
2257~
        """ Convert prices dictionary to local timezone. """
2258~
        local_prices = []
2259~
        for price_data in prices_dict:
2260~
            local_date_from = price_data['from'].astimezone(timezone)
2261~
            local_date_till = price_data['till'].astimezone(timezone)
2262~
            local_price_data = {
2263~
                'from': local_date_from,
2264~
                'till': local_date_till,
2265~
                'price': price_data['price']
2266~
            }
2267~
            local_prices.append(local_price_data)
2268~
        return local_prices
2269~

2270~
    def test_asdict(self, attr):  # remove me
2271~
        """Return a dict that can be used as entity attribute data."""
2272~
        result = []
2273~
        for e in self.price_data:
2274~
            data = {
2275~
                "from": e.date_from,
2276~
                "till": e.date_till,
2277~
                "date_from": e.date_from,
2278~
                "date_till": e.date_till,
2279~
                "market_price": e.market_price,
2280~
                "market_price_tax": e.market_price_tax,
2281~
                "sourcing_markup_price": e.sourcing_markup_price,
2282~
                "energy_tax_price": e.energy_tax_price,
2283~
                "total": e.total,
2284~
                "price": getattr(e, attr)
2285~
            }
2286~
            result.append(data)
2287~
        return result
2288~

2289~
    def calculate_stats(self):
2290~
        electricity_prices = [
2291~
            price.total for price in self if price.electricity]
2292~
        gas_prices = [price.total for price in self if price.gas]
2293~

2294~
        electricity_mean = mean(electricity_prices)
2295~
        gas_mean = mean(gas_prices)
2296~

2297~
        electricity_min = min(electricity_prices)
2298~
        gas_min = min(gas_prices)
2299~

2300~
        electricity_max = max(electricity_prices)
2301~
        gas_max = max(gas_prices)
2302~

2303~
        return {
2304~
            'electricity': {
2305~
                'mean': electricity_mean,
2306~
                'min': electricity_min,
2307~
                'max': electricity_max
2308~
            },
2309~
            'gas': {
2310~
                'mean': gas_mean,
2311~
                'min': gas_min,
2312~
                'max': gas_max
2313~
            }
2314~
        }
2315~

2316~
    def calculate_stats(data):
2317~
        print(data)
2318~
        electricity_prices = data.MarketPrices.electricity
2319~
        gas_prices = data.MarketPrices.gas
2320~

2321~
        # Calculate total market price and total market price tax and the total price
2322~
        total_market_price = sum(
2323~
            price.market_price for price in electricity_prices)
2324~
        total_market_price_with_tax = sum(
2325~
            price.market_price_with_tax for price in electricity_prices)
2326~
        total_price = sum(price.total for price in electricity_prices)
2327~

2328~
        # Calculate average prices
2329~
        average_market_price = total_market_price / len(electricity_prices)
2330~
        average_market_price_with_tax = total_market_price_with_tax / \
2331~
            len(electricity_prices)
2332~
        average_total_price = total_price / len(electricity_prices)
2333~

2334~
        # Find the minimum and maximum prices
2335~
        min_market_price = min(
2336~
            price.market_price for price in electricity_prices)
2337~
        max_market_price = max(
2338~
            price.market_price for price in electricity_prices)
2339~
        min_market_price_with_tax = min(
2340~
            price.market_price_with_tax for price in electricity_prices)
2341~
        max_market_price_with_tax = max(
2342~
            price.market_price_with_tax for price in electricity_prices)
2343~
        min_total_price = min(price.total for price in electricity_prices)
2344~
        max_total_price = max(price.total for price in electricity_prices)
2345~

2346~
        # Find the time interval with the highest market price
2347~
        max_market_price_interval = max(
2348~
            electricity_prices, key=lambda x: x['marketPrice'])
2349~
        max_market_price_from = datetime.fromisoformat(
2350~
            max_market_price_interval['from'])
2351~
        max_market_price_till = datetime.fromisoformat(
2352~
            max_market_price_interval['till'])
2353~

2354~
        # Find the time interval with the lowest market price
2355~
        min_market_price_interval = min(
2356~
            electricity_prices, key=lambda x: x['marketPrice'])
2357~
        min_market_price_from = datetime.fromisoformat(
2358~
            min_market_price_interval['from'])
2359~
        min_market_price_till = datetime.fromisoformat(
2360~
            min_market_price_interval['till'])
2361~

2362~
        # Compile the statistics into a dictionary
2363~
        stats = {
2364~
            'total_market_price': total_market_price,
2365~
            'total_market_price_tax': total_market_price_with_tax,
2366~
            'total_price': total_price,
2367~
            'average_market_price': average_market_price,
2368~
            'average_market_price_with_tax': average_market_price_with_tax,
2369~
            'average_total_price': average_total_price,
2370~
            'min_market_price': min_market_price,
2371~
            'max_market_price': max_market_price,
2372~
            'min_market_price_from': min_market_price_from,
2373~
            'min_market_price_till': min_market_price_till,
2374~
            'max_market_price_from': max_market_price_from,
2375~
            'max_market_price_till': max_market_price_till
2376~
        }
2377~

2378~
        return stats
2379~

2380~
    @property
2381~
    def today_prices(self) -> list[Price]:
2382~
        """ Get a list of all the prices for today. """
2383~
        return list(filter(lambda hour: hour.for_today, self.price_data))
2384~

2385~
    @property
2386~
    def today_market_avg(self) -> float:
2387~
        """ Average market price for today. """
2388~
        today_market_prices = [
2389~
            hour.market_price for hour in self.today_prices]
2390~
        return mean(today_market_prices)
2391~

2392~
    def get_price_statistics(price_data: 'PriceData', start_date: datetime, end_date: datetime) -> Union[dict, None]:
2393~
        """Calculate statistics for prices within a specific date range."""
2394~
        filtered_prices = price_data.filter_prices(start_date, end_date)
2395~
        if filtered_prices:
2396~
            prices = [price.total for price in filtered_prices]
2397~
            return {
2398~
                "min_price": min(prices),
2399~
                "max_price": max(prices),
2400~
                "avg_price": mean(prices),
2401~
                "total_price": sum(prices),
2402~
                "std_dev": (sum((x - mean(prices)) ** 2 for x in prices) / len(prices)) ** 0.5,
2403~
            }
2404~
        return None
2405~

2406~
    @staticmethod
2407~
    def from_dict(data: dict[str, list[dict[str, str]]]) -> Optional['PriceData']:
2408~
        """Parse the response from the marketPrices query."""
2409~
        _LOGGER.debug("PriceData %s", data)
2410~

2411~
        if errors := data.get("errors"):
2412~
            raise RequestException(errors[0]["message"])
2413~

2414~
        payload = data.get("data", {}).get("marketPrices")
2415~
        if payload is None:
2416~
            raise RequestException("Unexpected response")
2417~

2418~
        # return PriceData(
2419~
        #    prices=[Price.from_dict(price_data) for price_data in payload],
2420~
        # )
2421~
        electricity_prices = payload.get("marketPricesElectricity", [])
2422~
        gas_prices = payload.get("marketPricesGas", [])
2423~
        prices = [Price(price_data)
2424~
                  for price_data in electricity_prices + gas_prices]
2425~
        energy_type = "electricity" if electricity_prices else "gas"
2426~

2427~
        return PriceData(prices=prices, energy_type=energy_type)
2428~

2429~
    @property
2430~
    def all_avg(self):
2431~
        """Get the average of all prices."""
2432~
        all_prices = [price for price in self.price_data]
2433~

2434~
        if not all_prices:
2435~
            return None
2436~

2437~
        avg = round(mean(price.total for price in all_prices), DEFAULT_ROUND)
2438~
        market_price_with_tax_and_markup_avg = round(mean(
2439~
            price.market_price_with_tax_and_markup for price in all_prices), DEFAULT_ROUND)
2440~
        market_price_with_tax_avg = round(mean(
2441~
            price.market_price_with_tax for price in all_prices), DEFAULT_ROUND)
2442~
        market_price_tax_avg = round(mean(
2443~
            price.market_price_tax for price in all_prices), DEFAULT_ROUND)
2444~
        market_price_markup_avg = round(mean(
2445~
            price.sourcing_markup_price for price in all_prices), DEFAULT_ROUND)
2446~
        market_price_avg = round(
2447~
            mean(price.market_price for price in all_prices), DEFAULT_ROUND)
2448~

2449~
        return type('PriceDataAvg', (object,), {'values': all_prices, 'total': avg, 'market_price_with_tax_and_markup': market_price_with_tax_and_markup_avg, 'market_markup_price': market_price_markup_avg, 'market_price_with_tax': market_price_with_tax_avg, 'market_price_tax': market_price_tax_avg, 'market_price': market_price_avg})
2450~

2451~
    @property
2452~
    def upcoming_avg(self) -> Optional[PriceDataAvg]:
2453~
        """Get the average of upcoming prices."""
2454~
        upcoming_prices = self.get_prices_for_time_period(TimePeriod.UPCOMING)
2455~

2456~
        if not upcoming_prices:
2457~
            return None
2458~

2459~
        avg = round(mean(price.total for price in upcoming_prices),
2460~
                    DEFAULT_ROUND)
2461~
        market_price_with_tax_and_markup_avg = round(mean(
2462~
            price.market_price_with_tax_and_markup for price in upcoming_prices), DEFAULT_ROUND)
2463~
        market_price_with_tax_avg = round(
2464~
            mean(price.market_price_with_tax for price in upcoming_prices), DEFAULT_ROUND)
2465~
        market_price_tax_avg = round(
2466~
            mean(price.market_price_tax for price in upcoming_prices), DEFAULT_ROUND)
2467~
        market_price_markup_avg = round(
2468~
            mean(price.sourcing_markup_price for price in upcoming_prices), DEFAULT_ROUND)
2469~
        market_price_avg = round(
2470~
            mean(price.market_price for price in upcoming_prices), DEFAULT_ROUND)
2471~

2472~
        """
2473~
        PriceDataAvg = namedtuple('PriceDataAvg', [
2474~
            'values', 'total', 'market_price_with_tax_and_markup',
2475~
            'market_markup_price', 'market_price_with_tax',
2476~
            'market_price_tax', 'market_price'
2477~
        ])
2478~
        """
2479~

2480~
        return PriceDataAvg(
2481~
            values=upcoming_prices,
2482~
            total=avg,
2483~
            market_price_with_tax_and_markup=market_price_with_tax_and_markup_avg,
2484~
            market_markup_price=market_price_markup_avg,
2485~
            market_price_with_tax=market_price_with_tax_avg,
2486~
            market_price_tax=market_price_tax_avg,
2487~
            market_price=market_price_avg
2488~
        )
2489~

2490~
    @property
2491~
    def tomorrow_avg(self) -> Optional[PriceDataAvg]:
2492~
        """Get the average of tomorrow's prices."""
2493~
        now = datetime.now(timezone.utc).astimezone()
2494~
        tomorrow = now + timedelta(days=1)
2495~
        tomorrow_start = tomorrow.replace(
2496~
            hour=0, minute=0, second=0, microsecond=0)
2497~
        tomorrow_end = tomorrow_start + timedelta(days=1)
2498~

2499~
        # tomorrow_prices = [
2500~
        #     price for price in self.price_data
2501~
        #     if tomorrow_start <= price.date_from < tomorrow_end
2502~
        # ]
2503~
        tomorrow_prices = self.get_prices_for_time_period(TimePeriod.TOMORROW)
2504~

2505~
        if not tomorrow_prices:
2506~
            return None
2507~

2508~
        avg = round(mean(price.total for price in tomorrow_prices),
2509~
                    DEFAULT_ROUND)
2510~
        market_price_with_tax_and_markup_avg = round(mean(
2511~
            price.market_price_including_tax_and_markup for price in tomorrow_prices), DEFAULT_ROUND)
2512~
        market_price_with_tax_avg = round(mean(
2513~
            price.market_price_including_tax for price in tomorrow_prices), DEFAULT_ROUND)
2514~
        market_price_tax_avg = round(
2515~
            mean(price.market_price_tax for price in tomorrow_prices), DEFAULT_ROUND)
2516~
        market_markup_price_avg = round(
2517~
            mean(price.sourcing_markup_price for price in tomorrow_prices), DEFAULT_ROUND)
2518~
        market_price_avg = round(
2519~
            mean(price.market_price for price in tomorrow_prices), DEFAULT_ROUND)
2520~

2521~
        """
2522~
        PriceDataAvg = namedtuple('PriceDataAvg', [
2523~
            'values', 'total', 'market_price_with_tax_and_markup',
2524~
            'market_markup_price', 'market_price_with_tax',
2525~
            'market_price_tax', 'market_price'
2526~
        ])
2527~
        """
2528~

2529~
        return PriceDataAvg(
2530~
            values=tomorrow_prices,
2531~
            total=avg,
2532~
            market_price_with_tax_and_markup=market_price_with_tax_and_markup_avg,
2533~
            market_markup_price=market_markup_price_avg,
2534~
            market_price_with_tax=market_price_with_tax_avg,
2535~
            market_price_tax=market_price_tax_avg,
2536~
            market_price=market_price_avg
2537~
        )
2538~

2539~
    @property
2540~
    def tomorrow_prices_market(self) -> list:
2541~
        """ Get the market prices for tomorrow"""
2542~
        current_hour_utc = datetime.now(timezone.utc).hour
2543~
        if not self.price_data or current_hour_utc > 21 or current_hour_utc < FETCH_TOMORROW_HOUR_UTC:
2544~
            return None
2545~
        # if -1 < datetime.now().hour < 15:
2546~
        #    return None
2547~

2548~
        today_prices = []
2549~
        tomorrow_prices = []
2550~
        for price in self.price_data:
2551~
            if price.for_today:
2552~
                today_prices.append(price.market_price)
2553~
            elif price.for_tomorrow:
2554~
                tomorrow_prices.append(price.market_price)
2555~
        if tomorrow_prices:
2556~
            return round(mean(tomorrow_prices), DEFAULT_ROUND)
2557~
        return None
2558~

2559~
    @property
2560~
    def tomorrow_prices_market_tax(self) -> list:
2561~
        """ Get the market prices incl tax for tomorrow"""
2562~
        current_hour_utc = datetime.now(timezone.utc).hour
2563~
        if not self.price_data or current_hour_utc > 21 or current_hour_utc < FETCH_TOMORROW_HOUR_UTC:
2564~
            return None
2565~

2566~
#        if not self.price_data:
2567~
#            return None
2568~
#        if -1 < datetime.now().hour < 15:
2569~
#            return None
2570~

2571~
        today_prices = []
2572~
        tomorrow_prices = []
2573~
        for price in self.price_data:
2574~
            if price.for_today:
2575~
                today_prices.append(price.market_price_including_tax)
2576~
            elif price.for_tomorrow:
2577~
                tomorrow_prices.append(price.market_price_including_tax)
2578~
        if tomorrow_prices:
2579~
            return round(mean(tomorrow_prices), DEFAULT_ROUND)
2580~
        return None
2581~

2582~
    @property
2583~
    def tomorrow_prices_market_tax_markup(self) -> list:
2584~
        """ Get the market prices incl tax and markup for tomorrow"""
2585~
        current_hour_utc = datetime.now(timezone.utc).hour
2586~
        if not self.price_data or current_hour_utc > 21 or current_hour_utc < FETCH_TOMORROW_HOUR_UTC:
2587~
            return None
2588~

2589~
#        if not self.price_data:
2590~
#            return None
2591~
#        if -1 < datetime.now().hour < 15:
2592~
#            return None
2593~

2594~
        today_prices = []
2595~
        tomorrow_prices = []
2596~
        for price in self.price_data:
2597~
            if price.for_today:
2598~
                today_prices.append(
2599~
                    price.market_price_including_tax_and_markup)
2600~
            elif price.for_tomorrow:
2601~
                tomorrow_prices.append(
2602~
                    price.market_price_including_tax_and_markup)
2603~
        if tomorrow_prices:
2604~
            return round(mean(tomorrow_prices), DEFAULT_ROUND)
2605~
        return None
2606~

2607~
    @property
2608~
    def today_prices_total(self) -> list:
2609~
        """ Get the market prices for today"""
2610~
        if not self.price_data:
2611~
            return None
2612~

2613~
        today_prices = []
2614~
        for price in self.price_data:
2615~
            if price.for_today:
2616~
                today_prices.append(price.total)
2617~
        if today_prices:
2618~
            return round(mean(today_prices), DEFAULT_ROUND)
2619~
        return None
2620~

2621~
    @property
2622~
    def tomorrow_prices_total(self) -> list:
2623~
        """ Get the market prices for tomorrow"""
2624~
        current_hour_utc = datetime.now(timezone.utc).hour
2625~
        if not self.price_data or current_hour_utc > 21 or current_hour_utc < FETCH_TOMORROW_HOUR_UTC:
2626~
            return None
2627~

2628~
#        if not self.price_data:
2629~
#            return None
2630~
#        if -1 < datetime.now().hour < 15:
2631~
#            return None
2632~

2633~
        tomorrow_prices = []
2634~
        for price in self.price_data:
2635~
            if price.for_tomorrow:
2636~
                tomorrow_prices.append(price.total)
2637~
        if tomorrow_prices:
2638~
            return round(mean(tomorrow_prices), DEFAULT_ROUND)
2639~
        return None
2640~

2641~
    @property
2642~
    def upcoming_min(self) -> Price:
2643~
        return min([hour for hour in self.upcoming], key=lambda hour: hour.total)
2644~

2645~
    @property
2646~
    def upcoming_max(self) -> Price:
2647~
        return max([hour for hour in self.upcoming], key=lambda hour: hour.total)
2648~

2649~
    @property
2650~
    def length(self) -> int:
2651~
        return len(self.price_data)
2652~

2653~
    @property
2654~
    def upcoming_market_avg(self):
2655~
        """Calculate the average market price of upcoming prices."""
2656~
        current_hour_end = self.current_hour.date_till
2657~
        upcoming_prices = [
2658~
            price for price in self.price_data if price.date_from > current_hour_end
2659~
        ]
2660~

2661~
        if not upcoming_prices:
2662~
            return None
2663~

2664~
        market_total_price = sum(
2665~
            price.market_price for price in upcoming_prices)
2666~
        return market_total_price / len(upcoming_prices)
2667~

2668~
    @property
2669~
    def upcoming_market_tax_markup_avg(self):
2670~
        """Calculate the average market price with tax of upcoming prices."""
2671~
        current_hour = self.current_hour
2672~
        upcoming_prices = [
2673~
            price for price in self.price_data if price.date_from > current_hour.date_till]
2674~
        total_price = sum(
2675~
            [price.market_price_with_tax_and_markup for price in upcoming_prices])
2676~
        if upcoming_prices:
2677~
            return total_price / len(upcoming_prices)
2678~
        else:
2679~
            return None
2680~

2681~
    @property
2682~
    def upcoming_market_tax_avg(self):
2683~
        """Calculate the average market price with tax of upcoming prices."""
2684~
        current_hour_end = self.current_hour.date_till
2685~
        upcoming_prices = [
2686~
            price for price in self.price_data if price.date_from > current_hour_end
2687~
        ]
2688~

2689~
        if not upcoming_prices:
2690~
            return None
2691~

2692~
        total_price_with_tax = sum(
2693~
            price.market_price_with_tax for price in upcoming_prices)
2694~
        average_price_with_tax = total_price_with_tax / len(upcoming_prices)
2695~

2696~
        return average_price_with_tax
2697~

2698~
    @property
2699~
    def today_gas_before6am(self) -> list[Price]:
2700~
        """ Get a list of gas prices for today before 6AM. """
2701~
        return [price.total for price in self.price_data if price.for_today and price.date_from.hour < 6]
2702~

2703~
    @property
2704~
    def today_gas_after6am(self) -> list[Price]:
2705~
        """ Get a list of gas prices for today after 6AM. """
2706~
        return [price.total for price in self.price_data if price.for_today and price.date_from.hour >= 6]
2707~

2708~
    @property
2709~
    def tomorrow_gas_before6am(self) -> list[Price]:
2710~
        """ Get a list of gas prices for tomorrow before 6AM. """
2711~
        return [price.total for price in self.price_data if price.for_tomorrow and price.date_from.hour < 6]
2712~

2713~
    @property
2714~
    def tomorrow_gas_after6am(self) -> list[Price]:
2715~
        """ Get a list of gas prices for tomorrow after 6AM. """
2716~
        return [price.total for price in self.price_data if price.for_tomorrow and price.date_from.hour >= 6]
2717~

2718~
    def get_prices_for_time_period(self, period: TimePeriod):
2719~
        if period == TimePeriod.TODAY:
2720~
            return [hour for hour in self.price_data if hour.for_today]
2721~
        elif period == TimePeriod.TOMORROW:
2722~
            return [hour for hour in self.price_data if hour.for_tomorrow]
2723~
        elif period == TimePeriod.UPCOMING:
2724~
            return [hour for hour in self.price_data if hour.for_upcoming]
2725~
        else:
2726~
            raise ValueError(f"Invalid time period: {period}")
2727~

2728~

2729~
@dataclass
2730~
class MarketPrices:
2731~
    """ Market prices for electricity and gas.
2732~

2733~
        Attributes:
2734~
        electricity (PriceData): The electricity price data.
2735~
        gas (PriceData): The gas price data.
2736~
        energy_type (Optional[str]): The type of energy (e.g., 'electricity' or 'gas').
2737~
        energy_country (str): The country code ('NL' or 'BE') for which the prices apply.
2738~
        today (list): Prices for today.
2739~
        tomorrow (list): Prices for tomorrow.
2740~
    """
2741~
    # note: zet velden zonder default altijd voor velden met default
2742~

2743~
    electricity: Optional[PriceData] = None
2744~
    gas: Optional[PriceData] = None
2745~
    energy_type: Optional[str] = None
2746~
    energy_country: str = "NL"  # Default to NL, can be overridden
2747~
    today: list = field(default_factory=list)
2748~
    tomorrow: list = field(default_factory=list)
2749~

2750~
#    def __init__(self, electricity: Optional[PriceData] = None, gas: Optional[PriceData] = None, energy_type: Optional[str] = None) -> None:
2751~
#         self.electricity = electricity
2752~
#         self.gas = gas
2753~
#         self.energy_type = energy_type
2754~

2755~
    @staticmethod
2756~
    def from_dict(data: dict[str, object]) -> 'MarketPrices':
2757~
        """Parse the response from the marketPrices query."""
2758~
        _LOGGER.debug("Prices %s", data)
2759~

2760~
        if errors := data.get("errors"):
2761~
            if errors[0]["message"].startswith("No marketprices found for segment"):
2762~
                return MarketPrices(PriceData(), PriceData())
2763~
            # raise RequestException(errors[0]["message"])
2764~

2765~
        payload = data.get("data")
2766~
        if payload is None:
2767~
            # raise RequestException("Unexpected response")
2768~
            return None
2769~

2770~
        # Get market prices from the payload
2771~
        market_prices_electricity = payload.get("marketPricesElectricity", {})
2772~
        market_prices_gas = payload.get("marketPricesGas", {})
2773~

2774~
        return MarketPrices(
2775~
            electricity=PriceData(market_prices_electricity,
2776~
                                  energy_type="electricity"),
2777~
            gas=PriceData(market_prices_gas, energy_type="gas"),
2778~
        )
2779~

2780~
    @classmethod
2781~
    def from_be_dict(cls, data: dict[str, object]) -> 'MarketPrices':
2782~
        """
2783~
        Create MarketPrices instance from BE market prices dict.
2784~

2785~
        Args:
2786~
            data: Dictionary with market prices data in BE format.
2787~

2788~
        Returns:
2789~
            MarketPrices instance populated from the provided dict.
2790~
        """
2791~
        _LOGGER.debug("BE Market Prices %s", data)
2792~

2793~
        # Defensive: if empty data, return empty PriceData
2794~
        if not data:
2795~
            return cls(PriceData(), PriceData())
2796~

2797~
        try:
2798~
            payload = data.get("data").get("marketPrices", {})
2799~
        except KeyError as err:
2800~
                    raise ValueError(f"Invalid response format: %s" % err) from err
2801~

2802~
        # electricity_data = data.get("electricityPrices", {})
2803~
        # gas_data = data.get("gasPrices", {})
2804~
        electricity_data = payload.get("electricityPrices", {})
2805~
        gas_data = payload.get("gasPrices", {})
2806~

2807~
        # Construct PriceData for electricity and gas similarly to other methods
2808~
        electricity_price_data = PriceData(electricity_data, energy_type="electricity")
2809~
        gas_price_data = PriceData(gas_data, energy_type="gas")
2810~

2811~
        return cls(
2812~
            electricity=electricity_price_data,
2813~
            gas=gas_price_data,
2814~
            energy_country="BE"
2815~
        )
2816~

2817~
    @staticmethod
2818~
    def from_userprices_dict(data: dict[str, object]) -> Optional['MarketPrices']:
2819~
        """Parse the response from the marketPrices query."""
2820~
        _LOGGER.debug("User Prices %s", data)
2821~

2822~
        # Return None if the data is empty
2823~
        # if not data:
2824~
        #    return None
2825~

2826~
        # Check for errors in the data
2827~
        if errors := data.get("errors"):
2828~
            # If the error message indicates no market prices found, return empty PriceData for both
2829~
            if errors[0]["message"].startswith("No marketprices found for segment"):
2830~
                return MarketPrices(PriceData(), PriceData())
2831~

2832~
            # Raise an exception for other errors
2833~
            raise RequestException(errors[0]["message"])
2834~

2835~
        # Extract the payload from the data
2836~
        payload = data.get("data")
2837~
        if payload is None:
2838~
            raise RequestException("Unexpected response")
2839~

2840~
        # Get customer market prices from the payload
2841~
        customer_market_prices = payload.get("customerMarketPrices", {})
2842~

2843~
        market_prices_electricity = customer_market_prices.get(
2844~
            "electricityPrices", {})
2845~
        market_prices_gas = customer_market_prices.get("gasPrices", {})
2846~

2847~
        # Debugging print to check what type of data is in customer_market_prices
2848~
        # print("TYPEDATA:", customer_market_prices.get("electricityPrices"))
2849~

2850~
        return MarketPrices(
2851~
            electricity=PriceData(market_prices_electricity,
2852~
                                  energy_type="electricity"),
2853~
            gas=PriceData(market_prices_gas, energy_type="gas"),
2854~
        )
2855~

2856~
@dataclass
2857~
class Session:
2858~
    """A trading session for a battery."""
2859~

2860~
    date: datetime
2861~
    trading_result: float
2862~
    cumulative_trading_result: float
2863~

2864~
    @staticmethod
2865~
    def from_dict(payload: dict[str, object]) -> 'SmartBatterySessions.Session':
2866~
        """Parse the sessions payload from the SmartBatterySessions query result."""
2867~
        _LOGGER.debug(" Parsing SmartBatterySessions.Session response: %s", payload)
2868~

2869~
        try:
2870~
            return SmartBatterySessions.Session(
2871~
                date=datetime.fromisoformat(payload["date"]).astimezone(timezone.utc),
2872~
                trading_result=float(payload["tradingResult"]),
2873~
                cumulative_trading_result=float(payload["cumulativeTradingResult"]),
2874~
            )
2875~
        except KeyError as exc:
2876~
            raise RequestException(f"Missing expected field in session: %s" % exc) from exc
2877~
        except ValueError as exc:
2878~
            raise RequestException("Invalid data format in session payload: %s" % exc) from exc
2879~

2880~

2881~
@dataclass
2882~
class SmartBatteries:
2883~
    """Collection of the users SmartBatteries."""
2884~

2885~
    smart_batteries: list["SmartBattery"] = field(default_factory=list)
2886~

2887~
    @staticmethod
2888~
    def from_dict(data: dict[str, object]) -> 'SmartBatteries':
2889~
        """Parse the response from the smartBatteries query."""
2890~

2891~
        if not data:
2892~
            _LOGGER.debug("No data found in smart batteries response.")
2893~
            # return SmartBatteries(smart_batteries=[])
2894~
            return SmartBatteries()
2895~
            # raise RequestException("Unexpected response")
2896~

2897~
        _LOGGER.debug("SmartBatteries %s", data)
2898~

2899~
        if errors := data.get("errors"):
2900~
            raise RequestException(errors[0]["message"])
2901~

2902~
        payload = data.get("smartBatteries")
2903~
        if not payload:
2904~
            raise RequestException("Unexpected response")
2905~
        if not isinstance(payload, list):
2906~
            raise RequestException("Expected 'smartBatteries' to be a list.")
2907~

2908~
        return SmartBatteries(
2909~
            smart_batteries=[
2910~
                SmartBattery.from_dict(smart_battery)
2911~
                for smart_battery in payload
2912~
                # for smart_battery in payload.get("smartBatteries", [])
2913~
            ],
2914~
        )
2915~

2916~
@dataclass
2917~
class SmartBatterySettings:
2918~
    """Battery configuration settings."""
2919~

2920~
    battery_mode: str
2921~
    imbalance_trading_strategy: str
2922~
    self_consumption_trading_allowed: bool
2923~

2924~
    @classmethod
2925~
    def from_dict(cls, data: dict) -> 'SmartBatterySettings':
2926~
        return cls(
2927~
            battery_mode=data["batteryMode"],
2928~
            imbalance_trading_strategy=data["imbalanceTradingStrategy"],
2929~
            self_consumption_trading_allowed=data["selfConsumptionTradingAllowed"]
2930~
        )
2931~

2932~
    def __str__(self) -> str:
2933~
        return (
2934~
            f"BatteryMode={self.battery_mode}, "
2935~
            f"Strategy={self.imbalance_trading_strategy}, "
2936~
            f"SelfConsumptionAllowed={self.self_consumption_trading_allowed}"
2937~
        )
2938~

2939~
@dataclass
2940~
class SmartBattery:
2941~
    """
2942~
    Core smart battery device data.
2943~

2944~
    Attributes:
2945~
        brand: Manufacturer or brand of the battery.
2946~
        capacity: Total storage capacity in kWh.
2947~
        external_reference: External identifier used by the provider or platform.
2948~
        id: Unique identifier of the battery.
2949~
        max_charge_power: Maximum charging power in kW.
2950~
        max_discharge_power: Maximum discharging power in kW.
2951~
        provider: Name of the service provider.
2952~
        created_at: Datetime the battery was registered (must be timezone-aware).
2953~
        updated_at: Datetime the battery was last updated (must be timezone-aware).
2954~
        settings: Optional battery configuration settings.
2955~
        sessions: List of usage sessions or historical interactions.
2956~
    """
2957~

2958~
    brand: str
2959~
    capacity: float
2960~
    id: str
2961~
    external_reference: str = ""
2962~
    max_charge_power: float = 0.0
2963~
    max_discharge_power: float = 0.0
2964~
    provider: str = ""
2965~
    created_at: datetime | None = None
2966~
    updated_at: datetime | None = None
2967~
    # settings: SmartBatterySettings = field(default_factory=SmartBatterySettings)
2968~
    settings: SmartBatterySettings | None = None
2969~
    # sessions: list["SmartBatterySession"] = field(default_factory=list)
2970~
    sessions: list[object] = field(default_factory=list)
2971~

2972~
    @staticmethod
2973~
    def from_dict(payload: dict[str, object]) -> "SmartBattery":
2974~
        """Parse the response for a single SmartBattery."""
2975~
        _LOGGER.debug("SmartBattery payload: %s", payload)
2976~

2977~
        created_at = None
2978~
        updated_at = None
2979~
        try:
2980~
            if 'created_at' in payload:
2981~
                created_at = datetime.fromisoformat(payload["created_at"]).astimezone(timezone.utc)
2982~
            if 'updated_at' in payload:
2983~
                updated_at = datetime.fromisoformat(payload["updated_at"]).astimezone(timezone.utc)
2984~
            if 'createdAt' in payload:
2985~
                created_at = datetime.fromisoformat(payload["createdAt"]).astimezone(timezone.utc)
2986~
            if 'updatedAt' in payload:
2987~
                updated_at = datetime.fromisoformat(payload["updatedAt"]).astimezone(timezone.utc)
2988~

2989~
        except KeyError as exc:
2990~
            raise ValueError("Missing expected datetime field: %s" % exc) from exc
2991~

2992~
        settings_data = payload.get("settings")
2993~
        settings = SmartBatterySettings(
2994~
            battery_mode=settings_data.get("batteryMode", ""),
2995~
            imbalance_trading_strategy=settings_data.get("imbalanceTradingStrategy", ""),
2996~
            self_consumption_trading_allowed=settings_data.get("selfConsumptionTradingAllowed", False),
2997~
        ) if settings_data else None
2998~

2999~
        sessions_data = payload.get("sessions", [])
3000~
        sessions = [SmartBatterySession.from_dict(s) for s in sessions_data]
3001~

3002~
        return SmartBattery(
3003~
            brand=payload.get("brand", ""),
3004~
            capacity=payload.get("capacity", 0.0),
3005~
            external_reference=payload.get("externalReference", ""),
3006~
            id=payload["id"],
3007~
            max_charge_power=payload.get("maxChargePower", 0.0),
3008~
            max_discharge_power=payload.get("maxDischargePower", 0.0),
3009~
            provider=payload.get("provider", ""),
3010~
            created_at=created_at,
3011~
            updated_at=updated_at,
3012~
            settings=settings,
3013~
            sessions=sessions,
3014~
        )
3015~

3016~

3017~
    @classmethod
3018~
    def from_dict_list(cls, items: list[object]) -> list["SmartBattery"]:
3019~
        """Convert a list of dictionaries to a list of SmartBattery instances."""
3020~
        return [cls(**item) if isinstance(item, dict) else item for item in items]
3021~

3022~
@dataclass
3023~
class SmartBatterySession:
3024~
    """A trading session for a smart battery."""
3025~

3026~
    date: date
3027~
    trading_result: float
3028~
    cumulative_trading_result: float
3029~
    cumulative_result: float
3030~
    result: float
3031~
    status: str
3032~
    tradeIndex: int | None
3033~

3034~
    @staticmethod
3035~
    def from_dict(payload: dict[str, object]) -> "SmartBatterySession":
3036~
        """Parse the session payload from SmartBatterySessions."""
3037~
        _LOGGER.debug(" Parsing SmartBatterySession: %s", payload)
3038~
        try:
3039~
            return SmartBatterySession(
3040~
                date=datetime.fromisoformat(payload["date"]).astimezone(timezone.utc),
3041~
                trading_result=payload["tradingResult"],
3042~
                cumulative_trading_result=payload["cumulativeTradingResult"],
3043~
                cumulative_result=payload["cumulativeResult"],
3044~
                result=payload["result"],
3045~
                status=payload["status"],
3046~
                tradeIndex=payload["tradeIndex"],
3047~
            )
3048~
        except KeyError as exc:
3049~
            raise ValueError("Missing expected field in session: %s" % exc) from exc
3050~
        except ValueError as exc:
3051~
            raise ValueError("Invalid data format in session payload: %s" % exc) from exc
3052~

3053~
@dataclass
3054~
class SmartBatterySessions:
3055~
    """Collection of smart battery trading sessions."""
3056~

3057~
    device_id: str
3058~
    fairuse_policy_verified: bool
3059~
    period_start_date: date
3060~
    period_end_date: date
3061~
    period_trade_index: int
3062~
    period_trading_result: float
3063~
    trading_result: float
3064~
    period_total_result: float
3065~
    period_imbalance_result: float
3066~
    period_epex_result: float
3067~
    period_frank_slim: float
3068~
    sessions: list[SmartBatterySession]
3069~
    total_trading_result: float
3070~

3071~
    @staticmethod
3072~
    def from_dict(data: dict[str, object]) -> 'SmartBatterySessions':
3073~
        """Parse the response from the SmartBatterySessions query."""
3074~
        _LOGGER.debug(" Parsing SmartBatterySessions response: %s", data)
3075~

3076~
        if errors := data.get("errors"):
3077~
            raise RequestException(errors[0]["message"])
3078~

3079~
        payload = data.get("data")
3080~
        if not payload:
3081~
            # return None
3082~
            raise RequestException("Unexpected response")
3083~

3084~
        smart_battery_session_data = payload.get("smartBatterySessions")
3085~
        
3086~
        return SmartBatterySessions(
3087~
            device_id=smart_battery_session_data.get("deviceId"),
3088~
            fairuse_policy_verified=smart_battery_session_data.get("fairusePolicyVerified", False),
3089~
            period_start_date=datetime.fromisoformat(smart_battery_session_data.get("periodStartDate")).astimezone(timezone.utc),
3090~
            period_end_date=datetime.fromisoformat(smart_battery_session_data.get("periodEndDate")).astimezone(timezone.utc),
3091~
            period_trade_index=int(smart_battery_session_data.get("periodTradeIndex") or 0),
3092~
            period_trading_result=float(smart_battery_session_data.get("periodTradingResult") or 0.0),
3093~
            trading_result=smart_battery_session_data.get("tradingResult") or 0.0,
3094~
            period_total_result=float(smart_battery_session_data.get("periodTotalResult") or 0.0),
3095~
            period_imbalance_result=float(smart_battery_session_data.get("periodImbalanceResult") or 0.0),
3096~
            period_epex_result=float(smart_battery_session_data.get("periodEpexResult") or 0.0),
3097~
            period_frank_slim=float(smart_battery_session_data.get("periodFrankSlim") or 0.0),
3098~
            sessions=[
3099~
                SmartBatterySession.from_dict(session)
3100~
                for session in smart_battery_session_data.get("sessions", [])
3101~
            ],
3102~
            total_trading_result=float(smart_battery_session_data.get("totalTradingResult") or 0.0),
3103~
        )
3104~

3105~
    def __iter__(self) -> Iterator:
3106~
        return iter(self.sessions)
3107~

3108~
    def __len__(self) -> int:
3109~
        return len(self.sessions)
3110~

3111~
    def __getitem__(self, index: int) -> SmartBatterySession:
3112~
        return self.sessions[index]
3113~

3114~
    def __str__(self) -> str:
3115~
        return f"SmartBatterySessions({self.device_id}, {len(self.sessions)} sessions, total_result={self.total_trading_result})"
3116~
    
3117~
@dataclass
3118~
class SmartBatterySummary:
3119~
    """Data representation of a smart battery session summary."""
3120~
    
3121~
    last_known_state_of_charge: int
3122~
    last_known_status: str
3123~
    last_update: datetime
3124~
    total_result: float
3125~

3126~
    @classmethod
3127~
    def from_dict(cls, data: dict[str, object]) -> "SmartBatterySummary":
3128~
        """
3129~
        Create a SmartBatterySummary from a dictionary.
3130~

3131~
        Args:
3132~
            data: Dictionary containing smart battery summary fields.
3133~

3134~
        Returns:
3135~
            SmartBatterySummary: Parsed dataclass instance.
3136~

3137~
        Raises:
3138~
            ValueError: If 'lastUpdate' is missing or invalid.
3139~
        """
3140~
        try:
3141~
            last_update = datetime.fromisoformat(data["lastUpdate"].replace("Z", "+00:00")).astimezone(timezone.utc)
3142~
        except (KeyError, ValueError) as e:
3143~
            raise ValueError("Invalid or missing 'lastUpdate' in smartBatterySummary") from e
3144~

3145~
        return cls(
3146~
            last_known_state_of_charge=data.get("lastKnownStateOfCharge", 0),
3147~
            last_known_status=data.get("lastKnownStatus", ""),
3148~
            last_update=last_update,
3149~
            total_result=data.get("totalResult", 0.0),
3150~
        )
3151~

3152~

3153~
@dataclass
3154~
class SmartBatteryDetails:
3155~
    """Complete smart battery data including configuration and summary."""
3156~

3157~
    smart_battery: SmartBattery
3158~
    smart_battery_summary: SmartBatterySummary
3159~
    smart_battery_settings: SmartBatterySettings | None = None
3160~

3161~
    @staticmethod
3162~
    def from_dict(data: dict[str, object]) -> "SmartBatteryDetails":
3163~
        """Parse SmartBatteryDetails from a raw dictionary."""
3164~

3165~
        sb_data = data.get("smartBattery", {})
3166~

3167~
        if not sb_data:
3168~
            raise ValueError("No smart battery data found")
3169~

3170~
        _LOGGER.debug("SmartBatteryDetails %s", sb_data)
3171~

3172~
        settings_data = sb_data.get("settings", {})
3173~
        _LOGGER.debug("SmartBatterySettings %s", settings_data)
3174~
        if not settings_data:
3175~
            _LOGGER.warning("No settings data found in smart battery data")
3176~
            settings_data = {}
3177~

3178~
        smart_battery_settings = SmartBatterySettings(
3179~
            battery_mode=settings_data.get("batteryMode", ""),
3180~
            imbalance_trading_strategy=settings_data.get("imbalanceTradingStrategy", ""),
3181~
            self_consumption_trading_allowed=settings_data.get("selfConsumptionTradingAllowed", False)
3182~
        )
3183~

3184~
        created_at_str = sb_data.get("createdAt")
3185~
        updated_at_str = sb_data.get("updatedAt")
3186~
        created_at_str = sb_data.get("created_at")
3187~
        updated_at_str = sb_data.get("updated_at")
3188~
        _LOGGER.debug("createdAttttt: %s, updatedAt: %s", created_at_str, updated_at_str)
3189~

3190~
        try:
3191~
            created_at = datetime.fromisoformat(created_at_str).astimezone(timezone.utc) if created_at_str else None
3192~
        except Exception as exc:
3193~
            _LOGGER.warning("Invalid or missing 'createdAt' in smart battery data: %s", created_at_str)
3194~
            created_at = None
3195~

3196~
        try:
3197~
            updated_at = datetime.fromisoformat(updated_at_str).astimezone(timezone.utc) if updated_at_str else None
3198~
        except Exception as exc:
3199~
            _LOGGER.warning("Invalid or missing 'updatedAt' in smart battery data: %s", updated_at_str)
3200~
            updated_at = None
3201~

3202~
        smart_battery = SmartBattery(
3203~
            brand=sb_data.get("brand", ""),
3204~
            capacity=sb_data.get("capacity", 0.0),
3205~
            external_reference=sb_data.get("externalReference", ""),
3206~
            id=sb_data.get("id", ""),
3207~
            settings=smart_battery_settings,
3208~
            max_charge_power=sb_data.get("maxChargePower", 0.0),
3209~
            max_discharge_power=sb_data.get("maxDischargePower", 0.0),
3210~
            provider=sb_data.get("provider", ""),
3211~
            updated_at=updated_at,
3212~
            created_at=created_at,
3213~
            sessions=[
3214~
                SmartBatterySession.from_dict(session)
3215~
                for session in sb_data.get("sessions", [])
3216~
            ],
3217~
        )
3218~

3219~
        summary_data = data.get("smartBatterySummary", {})
3220~
        last_update = datetime.fromisoformat(summary_data["lastUpdate"].replace("Z", "+00:00"))
3221~

3222~
        smart_battery_summary = SmartBatterySummary.from_dict(summary_data)
3223~

3224~
        return SmartBatteryDetails(
3225~
            smart_battery=smart_battery,
3226~
            smart_battery_summary=smart_battery_summary
3227~
        )
3228~

3229~
def parse_utc_isoformat(value: str) -> datetime:
3230~
    """Convert ISO8601 datetime string to UTC-aware datetime."""
3231~
    return datetime.fromisoformat(value.replace("Z", "+00:00")).astimezone(timezone.utc)
3232~

3233~
def parse_datetime(value: object) -> datetime | None:
3234~
    if isinstance(value, datetime):
3235~
        return value
3236~
    if isinstance(value, str):
3237~
        try:
3238~
            return parse_utc_isoformat(value)
3239~
        except (ValueError, TypeError):
3240~
            _LOGGER.warning("Invalid datetime string: %s", value)
3241~
    return None
3242~

3243~
@dataclass
3244~
class BatterySessionSummary:
3245~
    active: bool
3246~
    charge_energy: float
3247~
    discharge_energy: float
3248~
    updated_at: str | datetime | None = None
3249~

3250~
    def __post_init__(self) -> None:
3251~
        if isinstance(self.updated_at, str):
3252~
            try:
3253~
                self.updated_at = parse_datetime(self.updated_at)
3254~
            except ValueError:
3255~
                _LOGGER.warning("Invalid updated_at format: %s", self.updated_at)
3256~
                self.updated_at = None
3257~

3258~

3259~
@dataclass
3260~
class BatteryEntityGroup:
3261~
    """
3262~
    Data representation of a battery entity group.
3263~

3264~
    Attributes:
3265~
        id: Unique identifier of the battery group.
3266~
        name: Human-readable name of the battery group.
3267~
        battery_ids: List of associated battery device IDs.
3268~
        created_at: Datetime when this group was created.
3269~
        updated_at: Datetime when this group was last updated.
3270~
        mode_sensor: Entity representing the battery mode.
3271~
        soc_sensor: Entity representing the state of charge.
3272~
        result_sensors: List of result sensor data.
3273~
    """
3274~

3275~
    id: str
3276~
    name: str
3277~
    battery_ids: list[str]
3278~
    created_at: datetime
3279~
    updated_at: datetime
3280~
    mode_sensor: object
3281~
    soc_sensor: object
3282~
    result_sensors: list["BatteryEntityGroup.ResultSensor"] = field(default_factory=list)
3283~

3284~
    @dataclass
3285~
    class ResultSensor:
3286~
        """
3287~
        Representation of an individual result sensor within a battery entity group.
3288~

3289~
        Attributes:
3290~
            type: Type of result (e.g., 'nettoresultaat').
3291~
            entity: Home Assistant entity representing the result.
3292~
        """
3293~
        type: str
3294~
        entity: object
3295~

3296~
        @classmethod
3297~
        def from_dict(cls, data: dict[str, object]) -> "BatteryEntityGroup.ResultSensor":
3298~
            """
3299~
            Create a ResultSensor from a dictionary.
3300~

3301~
            Args:
3302~
                data: Dictionary with result sensor data.
3303~

3304~
            Returns:
3305~
                ResultSensor instance.
3306~
            """
3307~
            return cls(
3308~
                type=data["type"],
3309~
                entity=data["entity"],
3310~
            )
3311~

3312~
        def to_dict(self) -> dict[str, object]:
3313~
            """
3314~
            Serialize ResultSensor to a dictionary.
3315~

3316~
            Returns:
3317~
                Dictionary representation of the result sensor.
3318~
            """
3319~
            return {
3320~
                "type": self.type,
3321~
                "entity": self.entity,
3322~
            }
3323~

3324~
    @classmethod
3325~
    def from_dict(cls, data: dict[str, object]) -> "BatteryEntityGroup":
3326~
        """
3327~
        Create a BatteryEntityGroup from a dictionary.
3328~

3329~
        Args:
3330~
            data: Dictionary containing battery entity group fields.
3331~

3332~
        Returns:
3333~
            BatteryEntityGroup instance.
3334~
        """
3335~
        try:
3336~
            created_at = datetime.fromisoformat(data["createdAt"]).astimezone(timezone.utc)
3337~
            updated_at = datetime.fromisoformat(data["updatedAt"]).astimezone(timezone.utc)
3338~
        except Exception as exc:
3339~
            raise ValueError("Invalid datetime format in 'createdAt' or 'updatedAt'") from exc
3340~

3341~
        return cls(
3342~
            id=data["id"],
3343~
            name=data["name"],
3344~
            battery_ids=data["batteryIds"],
3345~
            created_at=created_at,
3346~
            updated_at=updated_at,
3347~
            mode_sensor=data.get("modeSensor"),
3348~
            soc_sensor=data.get("socSensor"),
3349~
            result_sensors=[
3350~
                cls.ResultSensor.from_dict(sensor)
3351~
                for sensor in data.get("resultSensors", [])
3352~
            ],
3353~
        )
3354~

3355~
    def to_dict(self) -> dict[str, object]:
3356~
        """
3357~
        Serialize BatteryEntityGroup to a dictionary.
3358~

3359~
        Returns:
3360~
            Dictionary representation of the battery entity group.
3361~
        """
3362~
        return {
3363~
            "id": self.id,
3364~
            "name": self.name,
3365~
            "batteryIds": self.battery_ids,
3366~
            "createdAt": self.created_at.isoformat(),
3367~
            "updatedAt": self.updated_at.isoformat(),
3368~
            "modeSensor": self.mode_sensor,
3369~
            "socSensor": self.soc_sensor,
3370~
            "resultSensors": [sensor.to_dict() for sensor in self.result_sensors],
3371~
        }
3372~

3373~
def battery_group_to_extra_state_attributes(group: BatteryEntityGroup) -> dict[str, object]:
3374~
    """
3375~
    Convert a BatteryEntityGroup instance into a dictionary suitable for use
3376~
    in Home Assistant's extra_state_attributes.
3377~

3378~
    Args:
3379~
        group: The BatteryEntityGroup instance.
3380~

3381~
    Returns:
3382~
        A dictionary representing extra state attributes.
3383~
    """
3384~
    return {
3385~
        "battery_group_id": group.id,
3386~
        "battery_group_name": group.name,
3387~
        "battery_ids": group.battery_ids,
3388~
        "created_at": group.created_at.isoformat(),
3389~
        "updated_at": group.updated_at.isoformat(),
3390~
        "mode_sensor": group.mode_sensor,
3391~
        "soc_sensor": group.soc_sensor,
3392~
        "result_sensors": [
3393~
            {
3394~
                "type": sensor.type,
3395~
                "entity": sensor.entity,
3396~
            }
3397~
            for sensor in group.result_sensors
3398~
        ],
3399~
    }
3400~
