"""Data models enable parsing and processing of the Frank Energie API responses in a structured manner."""
# python_frank_energie/models.py

import logging
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone, tzinfo
from statistics import mean
from typing import Optional

import jwt
import pytz

from jwt.exceptions import InvalidTokenError
from dateutil.parser import parse
from .exceptions import AuthException

DEFAULT_ROUND = 6

_LOGGER: logging.Logger = logging.getLogger(__name__)

VERSION = "2025.5.23"
FETCH_TOMORROW_HOUR_UTC = 12

@dataclass
class Authentication:
    """Authentication data.

    Generated by the login or renewToken mutation.

    authToken: The token to use for authenticated requests.
    refreshToken: The token to use to renew the authToken.
    """

    authToken: str
    refreshToken: str
    expires_at: datetime | None = None

    @staticmethod
    def from_dict(data: dict[str, str]) -> 'Authentication':
        """Parse the response from the login or renewToken mutation."""
        _LOGGER.debug("Authentication %s", data)

        if errors := data.get("errors"):
            raise AuthException(errors[0]["message"])

        login_payload = data.get("data", {}).get("login")
        renew_payload = data.get("data", {}).get("renewToken")
        if not login_payload and not renew_payload:
            raise AuthException("Unexpected response")

        payload = Authentication._extract_payload(data)
        if not payload:
            raise AuthException("Unexpected response")

        _LOGGER.debug("Authentication payload: %s", payload)
        auth_token = payload.get("authToken")

        refresh_token = payload.get("refreshToken")

        expires_at = None
        if auth_token:
            try:
                decoded = jwt.decode(
                    auth_token,
                    options={"verify_signature": False},
                    algorithms=["HS256"],
                )
                _LOGGER.debug("authToken decoded claims: %s", decoded)
                exp_ts = decoded.get("exp")
                if exp_ts:
                    expires_at = datetime.fromtimestamp(exp_ts, tz=timezone.utc)
                else:
                    _LOGGER.warning("authToken missing 'exp' claim; treating as expired")
                    expires_at = None
                _LOGGER.debug("authToken expires at: %s", expires_at)
            except InvalidTokenError as err:
                _LOGGER.warning("Unable to decode authToken to extract expiration: %s", err)

        return Authentication(
            authToken=auth_token,
            refreshToken=refresh_token,
            expires_at=expires_at,
        )

    @staticmethod
    def _extract_payload(data: dict) -> Optional[dict]:
        """Extract the login or renewToken payload from the data dictionary."""
        return data.get("data", {}).get("login") or data.get("data", {}).get("renewToken")

    def old_authTokenValid(self, tz: timezone = timezone.utc) -> bool:
        """Return that authToken is valid according to expiration time."""
        authTokenDecoded = jwt.decode(
            self.authToken,
            verify=True,
            algorithms=["HS256"],
            options={"verify_signature": False},
        )
        return datetime.fromtimestamp(
            authTokenDecoded["exp"], tz=timezone.utc
        ) > datetime.now(tz=tz)

    def old_auth_token_valid(self, tz: tzinfo = timezone.utc) -> bool:
        """
        Check if the authToken is still valid based on its expiration timestamp.

        Args:
            tz (tzinfo): The timezone to compare the expiration against. Defaults to UTC.

        Returns:
            bool: True if the token is still valid, False otherwise.

        Raises:
            ValueError: If the authToken is missing or malformed.
        """
        if not self.authToken:
            raise ValueError("authToken is missing or not set.")

        try:
            auth_token_decoded = jwt.decode(
                self.authToken,
                options={"verify_signature": False},
                algorithms=["HS256"],
            )
        except InvalidTokenError as err:
            _LOGGER.warning("Failed to decode authToken: %s", err)
            raise ValueError("Malformed authToken.") from err

        expiration = datetime.fromtimestamp(auth_token_decoded.get("exp", 0), tz=timezone.utc)
        return expiration > datetime.now(tz=tz)

    @property
    def is_expired(self) -> bool:
        """Check if the token is expired based on the expires_at field."""
        return not self.expires_at or datetime.now(timezone.utc) >= self.expires_at

@dataclass
class Invoice:
    """Represents invoice information, including the start date, period
    description, and total amount."""

    StartDate: datetime
    PeriodDescription: str
    TotalAmount: float

    @property
    def for_last_year(self) -> bool:
        """Whether this invoice is for the current year."""
        last_year = datetime.now(pytz.timezone('Europe/Amsterdam')).year - 1
        invoice_start_date_utc = self.StartDate.replace(tzinfo=pytz.UTC)
        invoice_start_year = invoice_start_date_utc.astimezone(
            pytz.timezone('Europe/Amsterdam')).year
        return invoice_start_year == last_year

    @property
    def for_this_year(self) -> bool:
        """Whether this invoice is for the current year."""
        current_year = datetime.now(
            pytz.timezone('Europe/Amsterdam')).year
        invoice_start_date_utc = self.StartDate.replace(tzinfo=pytz.UTC)
        invoice_start_year = invoice_start_date_utc.astimezone(
            pytz.timezone('Europe/Amsterdam')).year
        return invoice_start_year == current_year

    @staticmethod
    def from_dict(data: dict[str, object]) -> Optional['Invoice']:
        """Parse the response from the invoice query."""
        if data is None:
            return None

        if isinstance(data, list):
            return [Invoice.from_dict(item) for item in data]

        return Invoice(
            StartDate=parse(data.get("StartDate")).astimezone(
                pytz.timezone('Europe/Amsterdam')),
            PeriodDescription=data.get("PeriodDescription"),
            TotalAmount=float(data.get("TotalAmount")),
        )

@dataclass
class Invoices:
    """Represents invoices including historical, current, and upcoming periods."""

    def __init__(
        self,
        allPeriodsInvoices: Optional[list[Invoice]] = None,
        previousPeriodInvoice: Optional[Invoice] = None,
        currentPeriodInvoice: Optional[Invoice] = None,
        upcomingPeriodInvoice: Optional[Invoice] = None,
        AllInvoicesDictForPreviousYear: dict = None,
        AllInvoicesDictForThisYear: dict = None,
        AllInvoicesDict: dict = None,
        TotalCostsPreviousYear: float = 0.0,
        TotalCostsThisYear: float = 0.0,
    ):
        if allPeriodsInvoices is None:
            allPeriodsInvoices = []
        if AllInvoicesDictForPreviousYear is None:
            AllInvoicesDictForPreviousYear = {}
        if AllInvoicesDictForThisYear is None:
            AllInvoicesDictForThisYear = {}
        if AllInvoicesDict is None:
            AllInvoicesDict = {}

        self.allPeriodsInvoices = allPeriodsInvoices
        self.previousPeriodInvoice = previousPeriodInvoice
        self.currentPeriodInvoice = currentPeriodInvoice
        self.upcomingPeriodInvoice = upcomingPeriodInvoice
        self.AllInvoicesDictForPreviousYear = AllInvoicesDictForPreviousYear
        self.AllInvoicesDictForThisYear = AllInvoicesDictForThisYear
        self.AllInvoicesDict = AllInvoicesDict
        self.TotalCostsPreviousYear = TotalCostsPreviousYear
        self.TotalCostsThisYear = TotalCostsThisYear

    # ... rest of Invoices methods unchanged ...

@dataclass
class Price:
    # ... fields and methods unchanged ...

    @property
    def for_today(self) -> bool:
        """Whether this price entry is for the current day."""
        now = datetime.now(timezone.utc).astimezone()
        day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        day_end = day_start + timedelta(days=1)
        return self.date_from >= day_start and self.date_till <= day_end

    @property
    def for_tomorrow(self) -> bool:
        """Whether this price entry is for tomorrow."""
        now = datetime.now(timezone.utc).astimezone()
        tomorrow = now + timedelta(days=1)
        tomorrow_start = tomorrow.replace(hour=0, minute=0, second=0, microsecond=0)
        tomorrow_end = tomorrow_start + timedelta(days=1)
        return tomorrow_start <= self.date_from < tomorrow_end

    # ... rest of Price methods unchanged ...

class PriceData:
    # ... init and other methods unchanged ...

    @property
    def today_min(self) -> Optional[Price]:
        """Price with the lowest total for today."""
        if self.today != []:
            return min([hour for hour in self.today], key=lambda hour: hour.total)

    @property
    def today_max(self) -> Optional[Price]:
        """Price with the highest total for today."""
        if self.today != []:
            return max([hour for hour in self.today], key=lambda hour: hour.total)

    @property
    def today_avg(self) -> float:
        """Average price for today."""
        if self.today != []:
            return mean(hour.total for hour in self.today)

    @property
    def tomorrow_min(self) -> Optional[Price]:
        """Price with the lowest total for tomorrow."""
        if self.tomorrow != []:
            return min([hour for hour in self.tomorrow], key=lambda hour: hour.total)

    @property
    def tomorrow_max(self) -> Optional[Price]:
        """Price with the highest total for tomorrow."""
        if self.tomorrow != []:
            return max([hour for hour in self.tomorrow], key=lambda hour: hour.total)

    # ... other properties and methods unchanged ...

@dataclass
class MarketPrices:
    """ Market prices for electricity and gas.
    """

    electricity: Optional[PriceData] = None
    gas: Optional[PriceData] = None
    energy_type: Optional[str] = None
    energy_country: str = "NL"
    today: list = field(default_factory=list)
    tomorrow: list = field(default_factory=list)

    @staticmethod
    def from_dict(data: dict[str, object]) -> 'MarketPrices':
        """Parse the response from the marketPrices query."""
        _LOGGER.debug("Prices %s", data)

        if (errors := data.get("errors")) and errors[0]["message"].startswith("No marketprices found for segment"):
            return MarketPrices(PriceData(), PriceData())
        # raise RequestException(errors[0]["message"])

        payload = data.get("data")
        if payload is None:
            return None

        market_prices_electricity = payload.get("marketPricesElectricity", {})
        market_prices_gas = payload.get("marketPricesGas", {})

        return MarketPrices(
            electricity=PriceData(market_prices_electricity, energy_type="electricity"),
            gas=PriceData(market_prices_gas, energy_type="gas"),
        )

    @classmethod
    def from_be_dict(cls, data: dict[str, object]) -> 'MarketPrices':
        """
        Create MarketPrices instance from BE market prices dict.
        """
        _LOGGER.debug("BE Market Prices %s", data)

        if not data:
            return cls(PriceData(), PriceData())

        try:
            payload = data.get("data").get("marketPrices", {})
        except KeyError as err:
            raise ValueError("Invalid response format: %s" % err) from err

        electricity_data = payload.get("electricityPrices", {})
        gas_data = payload.get("gasPrices", {})

        electricity_price_data = PriceData(electricity_data, energy_type="electricity")
        gas_price_data = PriceData(gas_data, energy_type="gas")

        return cls(
            electricity=electricity_price_data,
            gas=gas_price_data,
            energy_country="BE"
        )

# ... other classes unchanged ...

@dataclass
class SmartBatteryDetails:
    # ... fields unchanged ...

    @staticmethod
    def from_dict(data: dict[str, object]) -> "SmartBatteryDetails":
        sb_data = data.get("smartBattery", {})
        if not sb_data:
            raise ValueError("No smart battery data found")

        _LOGGER.debug("SmartBatteryDetails %s", sb_data)

        settings_data = sb_data.get("settings", {})
        _LOGGER.debug("SmartBatterySettings %s", settings_data)
        if not settings_data:
            _LOGGER.warning("No settings data found in smart battery data")
            settings_data = {}

        smart_battery_settings = SmartBatterySettings(
            battery_mode=settings_data.get("batteryMode", ""),
            imbalance_trading_strategy=settings_data.get("imbalanceTradingStrategy", ""),
            self_consumption_trading_allowed=settings_data.get("selfConsumptionTradingAllowed", False)
        )

        created_at_str = sb_data.get("createdAt") or sb_data.get("created_at")
        updated_at_str = sb_data.get("updatedAt") or sb_data.get("updated_at")
        _LOGGER.debug("createdAt: %s, updatedAt: %s", created_at_str, updated_at_str)

        try:
            created_at = datetime.fromisoformat(created_at_str).astimezone(timezone.utc) if created_at_str else None
        except Exception:
            _LOGGER.warning("Invalid or missing 'createdAt' in smart battery data: %s", created_at_str)
            created_at = None

        try:
            updated_at = datetime.fromisoformat(updated_at_str).astimezone(timezone.utc) if updated_at_str else None
        except Exception:
            _LOGGER.warning("Invalid or missing 'updatedAt' in smart battery data: %s", updated_at_str)
            updated_at = None

        smart_battery = SmartBattery(
            brand=sb_data.get("brand", ""),
            capacity=sb_data.get("capacity", 0.0),
            external_reference=sb_data.get("externalReference", ""),
            id=sb_data.get("id", ""),
            settings=smart_battery_settings,
            max_charge_power=sb_data.get("maxChargePower", 0.0),
            max_discharge_power=sb_data.get("maxDischargePower", 0.0),
            provider=sb_data.get("provider", ""),
            updated_at=updated_at,
            created_at=created_at,
            sessions=[
                SmartBatterySession.from_dict(session)
                for session in sb_data.get("sessions", [])
            ],
        )

        summary_data = data.get("smartBatterySummary", {})
        smart_battery_summary = SmartBatterySummary.from_dict(summary_data)

        return SmartBatteryDetails(
            smart_battery=smart_battery,
            smart_battery_summary=smart_battery_summary
        )